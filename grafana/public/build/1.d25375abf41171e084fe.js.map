{"version":3,"sources":["webpack:///./public/app/core/table_model.ts","webpack:///./public/vendor/flot/jquery.flot.js","webpack:///./public/vendor/flot/jquery.flot.time.js"],"names":["TableModel","this","columns","columnMap","rows","type","prototype","sort","options","col","length","a","b","desc","reverse","addColumn","text","push","addRow","row","$","color","make","r","g","o","add","c","d","i","charAt","normalize","scale","f","toString","join","clamp","min","value","max","parseInt","clone","extract","elem","css","toLowerCase","parent","nodeName","get","parse","str","res","m","exec","parseFloat","name","trim","lookupColors","aqua","azure","beige","black","blue","brown","cyan","darkblue","darkcyan","darkgrey","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkviolet","fuchsia","gold","green","indigo","khaki","lightblue","lightcyan","lightgreen","lightgrey","lightpink","lightyellow","lime","magenta","maroon","navy","olive","orange","pink","purple","violet","red","silver","white","yellow","jQuery","hasOwnProperty","Object","Canvas","cls","container","element","children","document","createElement","className","direction","position","left","top","appendTo","getContext","window","G_vmlCanvasManager","Error","initElement","context","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","pixelRatio","resize","width","height","textContainer","_textCache","_textSizeCache","flotTextSizeCache","Plot","placeholder","data_","options_","plugins","series","colors","legend","show","noColumns","labelFormatter","labelBoxBorderColor","margin","backgroundColor","backgroundOpacity","sorted","xaxis","mode","font","tickColor","transform","inverseTransform","autoscaleMargin","ticks","tickFormatter","labelWidth","labelHeight","reserveSpace","tickLength","alignTicksWithAxis","tickDecimals","tickSize","minTickSize","yaxis","xaxes","yaxes","points","radius","lineWidth","fill","fillColor","symbol","lines","steps","bars","barWidth","align","horizontal","zero","shadowSize","highlightColor","grid","aboveData","borderColor","labelMargin","eventSectionHeight","axisMargin","borderWidth","minBorderMargin","markings","markingsColor","markingsLineWidth","clickable","hoverable","autoHighlight","mouseActiveRadius","interaction","redrawOverlayInterval","hooks","surface","overlay","eventHolder","ctx","octx","plotOffset","right","bottom","plotWidth","plotHeight","processOptions","processRawData","processDatapoints","processOffset","processRange","drawBackground","drawSeries","draw","bindEvents","drawOverlay","shutdown","plot","executeHooks","hook","args","concat","apply","setData","s","extend","data","parseData","neededColors","maxIndex","sc","colorPool","colorPoolSize","variation","colori","v","getOrCreateAxis","axisNumber","fillInSeriesOptions","j","k","ps","val","p","format","topSentry","Number","POSITIVE_INFINITY","bottomSentry","NEGATIVE_INFINITY","fakeInfinity","MAX_VALUE","updateAxis","axis","datamin","datamax","each","allAxes","_","used","datapoints","x","number","required","y","autoscale","defaultValue","pointsize","insertSteps","nullify","isNaN","Infinity","xmin","ymin","xmax","ymax","delta","processData","obj","coord","n","grep","canvasToAxisCoords","pos","c2p","undefined","x1","y1","axes","redrawTimeout","clearTimeout","unbind","onMouseMove","onMouseLeave","onClick","measureTickLabels","opts","maxWidth","Math","floor","legacyStyles","layer","t","label","info","getTextInfo","allocateAxisBoxFirstPhase","lw","lh","isXAxis","padding","eventSectionPadding","innermost","outermost","first","found","box","setupGrid","showGrid","axisOpts","widen","abs","setRange","allocatedAxes","snaped","setupTickGeneration","setTicks","snapRangeToTicks","minMargin","margins","ceil","adjustLayoutForThingsStickingOut","allocateAxisBoxSecondPhase","identity","it","p2c","setTransformationHelpers","tick","halign","valign","removeText","addText","html","find","remove","fragments","entries","rowStarted","lf","isFunction","ascending","entry","table","replace","div","prependTo","insertLegend","noTicks","sqrt","dec","log","LN10","maxDec","size","magn","pow","norm","scaledDecimals","tickGenerator","prev","start","base","floorInBase","NaN","factor","formatted","round","decimal","indexOf","precision","substr","otherAxis","niceTicks","extraDec","ts","test","toFixed","oticks","changed","clear","save","translate","fillStyle","getColorOrGradient","fillRect","restore","drawGrid","render","triggerRedrawOverlay","extractRange","ranges","from","to","key","tmp","bw","bc","getAxes","xrange","yrange","xequal","yequal","subPixel","beginPath","strokeStyle","moveTo","lineTo","stroke","xoff","yoff","strokeRect","plotLine","xoffset","yoffset","axisx","axisy","prevx","prevy","x2","y2","lineJoin","sw","angle","PI","sin","cos","getFillStyle","areaOpen","ypos","segmentStart","segmentEnd","x1old","x2old","plotLineArea","drawSeriesLines","barLeft","fillStyleCallback","barRight","drawBar","plotBars","drawSeriesBars","plotPoints","offset","shadow","arc","closePath","w","drawSeriesPoints","drawLeft","drawRight","drawTop","drawBottom","filloptions","seriesColor","getPlaceholder","getCanvas","getPlotOffset","getData","getXAxes","getYAxes","getOptions","highlight","unhighlight","pointOffset","point","destroy","removeData","empty","highlights","classes","init","initPlugins","axisOptions","axisCount","fontSize","fontSizeDefault","fontDefaults","style","variant","weight","family","lineHeight","x2axis","y2axis","coloredAreas","coloredAreasColor","parseOptions","existing","setupCanvases","mousemove","bind","click","e","triggerClickHoverEvent","isSelecting","eventname","event","seriesFilter","canvasX","pageX","canvasY","pageY","ctrlKey","metaKey","item","mouseX","mouseY","maxDistance","smallestDistance","mx","my","maxx","maxy","dx","dy","dist","datapoint","slice","dataIndex","seriesIndex","findNearbyItem","h","auto","trigger","setTimeout","hi","drawBarHighlight","drawPointHighlight","indexOfHighlight","splice","pointRadius","spec","defaultColor","gradient","createLinearGradient","l","co","brightness","opacity","addColorStop","fn","detach","parentNode","removeChild","clearRect","cache","layerKey","call","getTextLayer","layerCache","styleKey","hide","styleCache","positions","active","rendered","append","font-size","insertAfter","addClass","textStyle","max-width","outerWidth","outerHeight","text-align","version","formatDate","fmt","monthNames","dayNames","strftime","hours12","leftPad","pad","escape","hours","getHours","isAM","getDay","getMonth","getDate","getMinutes","getSeconds","getFullYear","makeUtcWrapper","addProxyMethod","sourceObj","sourceMethod","targetObj","targetMethod","arguments","utc","date","props","dateGenerator","timezone","Date","timezoneJS","setTimezone","setTime","timeUnitSize","second","minute","hour","day","month","quarter","year","baseSpec","specMonths","specQuarters","axisName","minSize","unit","step","setSeconds","setMinutes","setHours","setMonth","setFullYear","setMilliseconds","setDate","carry","getTime","end","timeformat","useQuarters","span","suffix","hourCode","twelveHourClock"],"mappings":"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","file":"1.d25375abf41171e084fe.js","sourcesContent":["interface Column {\r\n  text: string;\r\n  title?: string;\r\n  type?: string;\r\n  sort?: boolean;\r\n  desc?: boolean;\r\n  filterable?: boolean;\r\n  unit?: string;\r\n}\r\n\r\nexport default class TableModel {\r\n  columns: Column[];\r\n  rows: any[];\r\n  type: string;\r\n  columnMap: any;\r\n\r\n  constructor() {\r\n    this.columns = [];\r\n    this.columnMap = {};\r\n    this.rows = [];\r\n    this.type = 'table';\r\n  }\r\n\r\n  sort(options) {\r\n    if (options.col === null || this.columns.length <= options.col) {\r\n      return;\r\n    }\r\n\r\n    this.rows.sort(function(a, b) {\r\n      a = a[options.col];\r\n      b = b[options.col];\r\n      // Sort null or undefined seperately from comparable values\r\n      return +(a == null) - +(b == null) || +(a > b) || -(a < b);\r\n    });\r\n\r\n    if (options.desc) {\r\n      this.rows.reverse();\r\n    }\r\n\r\n    this.columns[options.col].sort = true;\r\n    this.columns[options.col].desc = options.desc;\r\n  }\r\n\r\n  addColumn(col) {\r\n    if (!this.columnMap[col.text]) {\r\n      this.columns.push(col);\r\n      this.columnMap[col.text] = col;\r\n    }\r\n  }\r\n\r\n  addRow(row) {\r\n    this.rows.push(row);\r\n  }\r\n}\r\n","/* Javascript plotting library for jQuery, version 0.8.3.\r\n\r\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\r\nLicensed under the MIT license.\r\n\r\n*/\r\n\r\n// first an inline dependency, jquery.colorhelpers.js, we inline it here\r\n// for convenience\r\n\r\n/* Plugin for jQuery for working with colors.\r\n *\r\n * Version 1.1.\r\n *\r\n * Inspiration from jQuery color animation plugin by John Resig.\r\n *\r\n * Released under the MIT license by Ole Laursen, October 2009.\r\n *\r\n * Examples:\r\n *\r\n *   $.color.parse(\"#fff\").scale('rgb', 0.25).add('a', -0.5).toString()\r\n *   var c = $.color.extract($(\"#mydiv\"), 'background-color');\r\n *   console.log(c.r, c.g, c.b, c.a);\r\n *   $.color.make(100, 50, 25, 0.4).toString() // returns \"rgba(100,50,25,0.4)\"\r\n *\r\n * Note that .scale() and .add() return the same modified object\r\n * instead of making a new one.\r\n *\r\n * V. 1.1: Fix error handling so e.g. parsing an empty string does\r\n * produce a color rather than just crashing.\r\n */\r\n(function($){$.color={};$.color.make=function(r,g,b,a){var o={};o.r=r||0;o.g=g||0;o.b=b||0;o.a=a!=null?a:1;o.add=function(c,d){for(var i=0;i<c.length;++i)o[c.charAt(i)]+=d;return o.normalize()};o.scale=function(c,f){for(var i=0;i<c.length;++i)o[c.charAt(i)]*=f;return o.normalize()};o.toString=function(){if(o.a>=1){return\"rgb(\"+[o.r,o.g,o.b].join(\",\")+\")\"}else{return\"rgba(\"+[o.r,o.g,o.b,o.a].join(\",\")+\")\"}};o.normalize=function(){function clamp(min,value,max){return value<min?min:value>max?max:value}o.r=clamp(0,parseInt(o.r),255);o.g=clamp(0,parseInt(o.g),255);o.b=clamp(0,parseInt(o.b),255);o.a=clamp(0,o.a,1);return o};o.clone=function(){return $.color.make(o.r,o.b,o.g,o.a)};return o.normalize()};$.color.extract=function(elem,css){var c;do{c=elem.css(css).toLowerCase();if(c!=\"\"&&c!=\"transparent\")break;elem=elem.parent()}while(elem.length&&!$.nodeName(elem.get(0),\"body\"));if(c==\"rgba(0, 0, 0, 0)\")c=\"transparent\";return $.color.parse(c)};$.color.parse=function(str){var res,m=$.color.make;if(res=/rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10));if(res=/rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10),parseFloat(res[4]));if(res=/rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*\\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55);if(res=/rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55,parseFloat(res[4]));if(res=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1],16),parseInt(res[2],16),parseInt(res[3],16));if(res=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1]+res[1],16),parseInt(res[2]+res[2],16),parseInt(res[3]+res[3],16));var name=$.trim(str).toLowerCase();if(name==\"transparent\")return m(255,255,255,0);else{res=lookupColors[name]||[0,0,0];return m(res[0],res[1],res[2])}};var lookupColors={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);\r\n\r\n// the actual Flot code\r\n(function($) {\r\n\r\n\t// Cache the prototype hasOwnProperty for faster access\r\n\r\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n    // A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM\r\n    // operation produces the same effect as detach, i.e. removing the element\r\n    // without touching its jQuery data.\r\n\r\n    // Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.\r\n\r\n    if (!$.fn.detach) {\r\n        $.fn.detach = function() {\r\n            return this.each(function() {\r\n                if (this.parentNode) {\r\n                    this.parentNode.removeChild( this );\r\n                }\r\n            });\r\n        };\r\n    }\r\n\r\n\t///////////////////////////////////////////////////////////////////////////\r\n\t// The Canvas object is a wrapper around an HTML5 <canvas> tag.\r\n\t//\r\n\t// @constructor\r\n\t// @param {string} cls List of classes to apply to the canvas.\r\n\t// @param {element} container Element onto which to append the canvas.\r\n\t//\r\n\t// Requiring a container is a little iffy, but unfortunately canvas\r\n\t// operations don't work unless the canvas is attached to the DOM.\r\n\r\n\tfunction Canvas(cls, container) {\r\n\r\n\t\tvar element = container.children(\".\" + cls)[0];\r\n\r\n\t\tif (element == null) {\r\n\r\n\t\t\telement = document.createElement(\"canvas\");\r\n\t\t\telement.className = cls;\r\n\r\n\t\t\t$(element).css({ direction: \"ltr\", position: \"absolute\", left: 0, top: 0 })\r\n\t\t\t\t.appendTo(container);\r\n\r\n\t\t\t// If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas\r\n\r\n\t\t\tif (!element.getContext) {\r\n\t\t\t\tif (window.G_vmlCanvasManager) {\r\n\t\t\t\t\telement = window.G_vmlCanvasManager.initElement(element);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(\"Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.element = element;\r\n\r\n\t\tvar context = this.context = element.getContext(\"2d\");\r\n\r\n\t\t// Determine the screen's ratio of physical to device-independent\r\n\t\t// pixels.  This is the ratio between the canvas width that the browser\r\n\t\t// advertises and the number of pixels actually present in that space.\r\n\r\n\t\t// The iPhone 4, for example, has a device-independent width of 320px,\r\n\t\t// but its screen is actually 640px wide.  It therefore has a pixel\r\n\t\t// ratio of 2, while most normal devices have a ratio of 1.\r\n\r\n\t\tvar devicePixelRatio = window.devicePixelRatio || 1,\r\n\t\t\tbackingStoreRatio =\r\n\t\t\t\tcontext.webkitBackingStorePixelRatio ||\r\n\t\t\t\tcontext.mozBackingStorePixelRatio ||\r\n\t\t\t\tcontext.msBackingStorePixelRatio ||\r\n\t\t\t\tcontext.oBackingStorePixelRatio ||\r\n\t\t\t\tcontext.backingStorePixelRatio || 1;\r\n\r\n\t\tthis.pixelRatio = devicePixelRatio / backingStoreRatio;\r\n\r\n\t\t// Size the canvas to match the internal dimensions of its container\r\n\r\n\t\tthis.resize(container.width(), container.height());\r\n\r\n\t\t// Collection of HTML div layers for text overlaid onto the canvas\r\n\r\n\t\tthis.textContainer = null;\r\n\t\tthis.text = {};\r\n\r\n\t\t// Cache of text fragments and metrics, so we can avoid expensively\r\n\t\t// re-calculating them when the plot is re-rendered in a loop.\r\n\r\n\t\tthis._textCache = {};\r\n\t\tthis._textSizeCache = window.flotTextSizeCache = window.flotTextSizeCache || {};\r\n\t}\r\n\r\n\t// Resizes the canvas to the given dimensions.\r\n\t//\r\n\t// @param {number} width New width of the canvas, in pixels.\r\n\t// @param {number} width New height of the canvas, in pixels.\r\n\r\n\tCanvas.prototype.resize = function(width, height) {\r\n\r\n\t\tif (width <= 0 || height <= 0) {\r\n\t\t\tthrow new Error(\"Invalid dimensions for plot, width = \" + width + \", height = \" + height);\r\n\t\t}\r\n\r\n\t\tvar element = this.element,\r\n\t\t\tcontext = this.context,\r\n\t\t\tpixelRatio = this.pixelRatio;\r\n\r\n\t\t// Resize the canvas, increasing its density based on the display's\r\n\t\t// pixel ratio; basically giving it more pixels without increasing the\r\n\t\t// size of its element, to take advantage of the fact that retina\r\n\t\t// displays have that many more pixels in the same advertised space.\r\n\r\n\t\t// Resizing should reset the state (excanvas seems to be buggy though)\r\n\r\n\t\tif (this.width != width) {\r\n\t\t\telement.width = width * pixelRatio;\r\n\t\t\telement.style.width = width + \"px\";\r\n\t\t\tthis.width = width;\r\n\t\t}\r\n\r\n\t\tif (this.height != height) {\r\n\t\t\telement.height = height * pixelRatio;\r\n\t\t\telement.style.height = height + \"px\";\r\n\t\t\tthis.height = height;\r\n\t\t}\r\n\r\n\t\t// Save the context, so we can reset in case we get replotted.  The\r\n\t\t// restore ensure that we're really back at the initial state, and\r\n\t\t// should be safe even if we haven't saved the initial state yet.\r\n\r\n\t\tcontext.restore();\r\n\t\tcontext.save();\r\n\r\n\t\t// Scale the coordinate space to match the display density; so even though we\r\n\t\t// may have twice as many pixels, we still want lines and other drawing to\r\n\t\t// appear at the same size; the extra pixels will just make them crisper.\r\n\r\n\t\tcontext.scale(pixelRatio, pixelRatio);\r\n\t};\r\n\r\n\t// Clears the entire canvas area, not including any overlaid HTML text\r\n\r\n\tCanvas.prototype.clear = function() {\r\n\t\tthis.context.clearRect(0, 0, this.width, this.height);\r\n\t};\r\n\r\n\t// Finishes rendering the canvas, including managing the text overlay.\r\n\r\n\tCanvas.prototype.render = function() {\r\n\r\n\t\tvar cache = this._textCache;\r\n\r\n\t\t// For each text layer, add elements marked as active that haven't\r\n\t\t// already been rendered, and remove those that are no longer active.\r\n\r\n\t\tfor (var layerKey in cache) {\r\n\t\t\tif (hasOwnProperty.call(cache, layerKey)) {\r\n\r\n\t\t\t\tvar layer = this.getTextLayer(layerKey),\r\n\t\t\t\t\tlayerCache = cache[layerKey];\r\n\r\n\t\t\t\tlayer.hide();\r\n\r\n\t\t\t\tfor (var styleKey in layerCache) {\r\n\t\t\t\t\tif (hasOwnProperty.call(layerCache, styleKey)) {\r\n\t\t\t\t\t\tvar styleCache = layerCache[styleKey];\r\n\t\t\t\t\t\tfor (var key in styleCache) {\r\n\t\t\t\t\t\t\tif (hasOwnProperty.call(styleCache, key)) {\r\n\r\n\t\t\t\t\t\t\t\tvar positions = styleCache[key].positions;\r\n\r\n\t\t\t\t\t\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\r\n\t\t\t\t\t\t\t\t\tif (position.active) {\r\n\t\t\t\t\t\t\t\t\t\tif (!position.rendered) {\r\n\t\t\t\t\t\t\t\t\t\t\tlayer.append(position.element);\r\n\t\t\t\t\t\t\t\t\t\t\tposition.rendered = true;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tpositions.splice(i--, 1);\r\n\t\t\t\t\t\t\t\t\t\tif (position.rendered) {\r\n\t\t\t\t\t\t\t\t\t\t\tposition.element.detach();\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (positions.length == 0) {\r\n\t\t\t\t\t\t\t\t\tdelete styleCache[key];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlayer.show();\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Creates (if necessary) and returns the text overlay container.\r\n\t//\r\n\t// @param {string} classes String of space-separated CSS classes used to\r\n\t//     uniquely identify the text layer.\r\n\t// @return {object} The jQuery-wrapped text-layer div.\r\n\r\n\tCanvas.prototype.getTextLayer = function(classes) {\r\n\r\n\t\tvar layer = this.text[classes];\r\n\r\n\t\t// Create the text layer if it doesn't exist\r\n\r\n\t\tif (layer == null) {\r\n\r\n\t\t\t// Create the text layer container, if it doesn't exist\r\n\r\n\t\t\tif (this.textContainer == null) {\r\n\t\t\t\tthis.textContainer = $(\"<div class='flot-text flot-temp-elem'></div>\")\r\n\t\t\t\t\t.css({\r\n\t\t\t\t\t\tposition: \"absolute\",\r\n\t\t\t\t\t\ttop: 0,\r\n\t\t\t\t\t\tleft: 0,\r\n\t\t\t\t\t\tbottom: 0,\r\n\t\t\t\t\t\tright: 0,\r\n\t\t\t\t\t\t'font-size': \"smaller\",\r\n\t\t\t\t\t\tcolor: \"#545454\"\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.insertAfter(this.element);\r\n\t\t\t}\r\n\r\n\t\t\tlayer = this.text[classes] = $(\"<div></div>\")\r\n\t\t\t\t.addClass(classes)\r\n\t\t\t\t.css({\r\n\t\t\t\t\tposition: \"absolute\",\r\n\t\t\t\t\ttop: 0,\r\n\t\t\t\t\tleft: 0,\r\n\t\t\t\t\tbottom: 0,\r\n\t\t\t\t\tright: 0\r\n\t\t\t\t})\r\n\t\t\t\t.appendTo(this.textContainer);\r\n\t\t}\r\n\r\n\t\treturn layer;\r\n\t};\r\n\r\n\t// Creates (if necessary) and returns a text info object.\r\n\t//\r\n\t// The object looks like this:\r\n\t//\r\n\t// {\r\n\t//     width: Width of the text's wrapper div.\r\n\t//     height: Height of the text's wrapper div.\r\n\t//     element: The jQuery-wrapped HTML div containing the text.\r\n\t//     positions: Array of positions at which this text is drawn.\r\n\t// }\r\n\t//\r\n\t// The positions array contains objects that look like this:\r\n\t//\r\n\t// {\r\n\t//     active: Flag indicating whether the text should be visible.\r\n\t//     rendered: Flag indicating whether the text is currently visible.\r\n\t//     element: The jQuery-wrapped HTML div containing the text.\r\n\t//     x: X coordinate at which to draw the text.\r\n\t//     y: Y coordinate at which to draw the text.\r\n\t// }\r\n\t//\r\n\t// Each position after the first receives a clone of the original element.\r\n\t//\r\n\t// The idea is that that the width, height, and general 'identity' of the\r\n\t// text is constant no matter where it is placed; the placements are a\r\n\t// secondary property.\r\n\t//\r\n\t// Canvas maintains a cache of recently-used text info objects; getTextInfo\r\n\t// either returns the cached element or creates a new entry.\r\n\t//\r\n\t// @param {string} layer A string of space-separated CSS classes uniquely\r\n\t//     identifying the layer containing this text.\r\n\t// @param {string} text Text string to retrieve info for.\r\n\t// @param {(string|object)=} font Either a string of space-separated CSS\r\n\t//     classes or a font-spec object, defining the text's font and style.\r\n\t// @param {number=} angle Angle at which to rotate the text, in degrees.\r\n\t//     Angle is currently unused, it will be implemented in the future.\r\n\t// @param {number=} width Maximum width of the text before it wraps.\r\n\t// @return {object} a text info object.\r\n\r\n\tCanvas.prototype.getTextInfo = function(layer, text, font, angle, width) {\r\n\r\n\t\tvar textStyle, layerCache, styleCache, info;\r\n\r\n\t\t// Cast the value to a string, in case we were given a number or such\r\n\r\n\t\ttext = \"\" + text;\r\n\r\n\t\t// If the font is a font-spec object, generate a CSS font definition\r\n\r\n\t\tif (typeof font === \"object\") {\r\n\t\t\ttextStyle = font.style + \" \" + font.variant + \" \" + font.weight + \" \" + font.size + \"px/\" + font.lineHeight + \"px \" + font.family;\r\n\t\t} else {\r\n\t\t\ttextStyle = font;\r\n\t\t}\r\n\r\n\t\t// Retrieve (or create) the cache for the text's layer and styles\r\n\r\n\t\tlayerCache = this._textCache[layer];\r\n\r\n\t\tif (layerCache == null) {\r\n\t\t\tlayerCache = this._textCache[layer] = {};\r\n\t\t}\r\n\r\n\t\tstyleCache = layerCache[textStyle];\r\n\r\n\t\tif (styleCache == null) {\r\n\t\t\tstyleCache = layerCache[textStyle] = {};\r\n\t\t}\r\n\r\n\t\tinfo = styleCache[text];\r\n\r\n\t\t// If we can't find a matching element in our cache, create a new one\r\n\r\n\t\tif (info == null) {\r\n\r\n\t\t\tvar element = $(\"<div></div>\").html(text)\r\n\t\t\t\t.css({\r\n\t\t\t\t\tposition: \"absolute\",\r\n\t\t\t\t\t'max-width': width,\r\n\t\t\t\t\ttop: -9999\r\n\t\t\t\t})\r\n\t\t\t\t.appendTo(this.getTextLayer(layer));\r\n\r\n\t\t\tif (typeof font === \"object\") {\r\n\t\t\t\telement.css({\r\n\t\t\t\t\tfont: textStyle,\r\n\t\t\t\t\tcolor: font.color\r\n\t\t\t\t});\r\n\t\t\t} else if (typeof font === \"string\") {\r\n\t\t\t\telement.addClass(font);\r\n\t\t\t}\r\n\r\n      info = styleCache[text] = { element: element, positions: [] };\r\n\r\n      var size = this._textSizeCache[text];\r\n\t\t\tif (size) {\r\n        info.width = size.width;\r\n        info.height = size.height;\r\n\t\t\t} else {\r\n        info.width = element.outerWidth(true);\r\n        info.height = element.outerHeight(true);\r\n        this._textSizeCache[text] = { width: info.width, height: info.height };\r\n\t\t\t}\r\n\t\t\telement.detach();\r\n\t\t}\r\n\r\n\t\treturn info;\r\n\t};\r\n\r\n\t// Adds a text string to the canvas text overlay.\r\n\t//\r\n\t// The text isn't drawn immediately; it is marked as rendering, which will\r\n\t// result in its addition to the canvas on the next render pass.\r\n\t//\r\n\t// @param {string} layer A string of space-separated CSS classes uniquely\r\n\t//     identifying the layer containing this text.\r\n\t// @param {number} x X coordinate at which to draw the text.\r\n\t// @param {number} y Y coordinate at which to draw the text.\r\n\t// @param {string} text Text string to draw.\r\n\t// @param {(string|object)=} font Either a string of space-separated CSS\r\n\t//     classes or a font-spec object, defining the text's font and style.\r\n\t// @param {number=} angle Angle at which to rotate the text, in degrees.\r\n\t//     Angle is currently unused, it will be implemented in the future.\r\n\t// @param {number=} width Maximum width of the text before it wraps.\r\n\t// @param {string=} halign Horizontal alignment of the text; either \"left\",\r\n\t//     \"center\" or \"right\".\r\n\t// @param {string=} valign Vertical alignment of the text; either \"top\",\r\n\t//     \"middle\" or \"bottom\".\r\n\r\n\tCanvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {\r\n\r\n\t\tvar info = this.getTextInfo(layer, text, font, angle, width),\r\n\t\t\tpositions = info.positions;\r\n\r\n\t\t// Tweak the div's position to match the text's alignment\r\n\r\n\t\tif (halign == \"center\") {\r\n\t\t\tx -= info.width / 2;\r\n\t\t} else if (halign == \"right\") {\r\n\t\t\tx -= info.width;\r\n\t\t}\r\n\r\n\t\tif (valign == \"middle\") {\r\n\t\t\ty -= info.height / 2;\r\n\t\t} else if (valign == \"bottom\") {\r\n\t\t\ty -= info.height;\r\n\t\t}\r\n\r\n\t\t// Determine whether this text already exists at this position.\r\n\t\t// If so, mark it for inclusion in the next render pass.\r\n\r\n\t\tfor (var i = 0, position; position = positions[i]; i++) {\r\n\t\t\tif (position.x == x && position.y == y) {\r\n\t\t\t\tposition.active = true;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If the text doesn't exist at this position, create a new entry\r\n\r\n\t\t// For the very first position we'll re-use the original element,\r\n\t\t// while for subsequent ones we'll clone it.\r\n\r\n\t\tposition = {\r\n\t\t\tactive: true,\r\n\t\t\trendered: false,\r\n\t\t\telement: positions.length ? info.element.clone() : info.element,\r\n\t\t\tx: x,\r\n\t\t\ty: y\r\n\t\t};\r\n\r\n\t\tpositions.push(position);\r\n\r\n\t\t// Move the element to its final position within the container\r\n\r\n\t\tposition.element.css({\r\n\t\t\ttop: Math.round(y),\r\n\t\t\tleft: Math.round(x),\r\n\t\t\t'text-align': halign\t// In case the text wraps\r\n\t\t});\r\n\t};\r\n\r\n\t// Removes one or more text strings from the canvas text overlay.\r\n\t//\r\n\t// If no parameters are given, all text within the layer is removed.\r\n\t//\r\n\t// Note that the text is not immediately removed; it is simply marked as\r\n\t// inactive, which will result in its removal on the next render pass.\r\n\t// This avoids the performance penalty for 'clear and redraw' behavior,\r\n\t// where we potentially get rid of all text on a layer, but will likely\r\n\t// add back most or all of it later, as when redrawing axes, for example.\r\n\t//\r\n\t// @param {string} layer A string of space-separated CSS classes uniquely\r\n\t//     identifying the layer containing this text.\r\n\t// @param {number=} x X coordinate of the text.\r\n\t// @param {number=} y Y coordinate of the text.\r\n\t// @param {string=} text Text string to remove.\r\n\t// @param {(string|object)=} font Either a string of space-separated CSS\r\n\t//     classes or a font-spec object, defining the text's font and style.\r\n\t// @param {number=} angle Angle at which the text is rotated, in degrees.\r\n\t//     Angle is currently unused, it will be implemented in the future.\r\n\r\n\tCanvas.prototype.removeText = function(layer, x, y, text, font, angle) {\r\n\t\tif (text == null) {\r\n\t\t\tvar layerCache = this._textCache[layer];\r\n\t\t\tif (layerCache != null) {\r\n\t\t\t\tfor (var styleKey in layerCache) {\r\n\t\t\t\t\tif (hasOwnProperty.call(layerCache, styleKey)) {\r\n\t\t\t\t\t\tvar styleCache = layerCache[styleKey];\r\n\t\t\t\t\t\tfor (var key in styleCache) {\r\n\t\t\t\t\t\t\tif (hasOwnProperty.call(styleCache, key)) {\r\n\t\t\t\t\t\t\t\tvar positions = styleCache[key].positions;\r\n\t\t\t\t\t\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\r\n\t\t\t\t\t\t\t\t\tposition.active = false;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar positions = this.getTextInfo(layer, text, font, angle).positions;\r\n\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\r\n\t\t\t\tif (position.x == x && position.y == y) {\r\n\t\t\t\t\tposition.active = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t///////////////////////////////////////////////////////////////////////////\r\n\t// The top-level container for the entire plot.\r\n\r\n    function Plot(placeholder, data_, options_, plugins) {\r\n        // data is on the form:\r\n        //   [ series1, series2 ... ]\r\n        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]\r\n        // or { data: [ [x1, y1], [x2, y2], ... ], label: \"some label\", ... }\r\n\r\n        var series = [],\r\n            options = {\r\n                // the color theme used for graphs\r\n                colors: [\"#edc240\", \"#afd8f8\", \"#cb4b4b\", \"#4da74d\", \"#9440ed\"],\r\n                legend: {\r\n                    show: true,\r\n                    noColumns: 1, // number of colums in legend table\r\n                    labelFormatter: null, // fn: string -> string\r\n                    labelBoxBorderColor: \"#ccc\", // border color for the little label boxes\r\n                    container: null, // container (as jQuery object) to put legend in, null means default on top of graph\r\n                    position: \"ne\", // position of default legend container within plot\r\n                    margin: 5, // distance from grid edge to default legend container within plot\r\n                    backgroundColor: null, // null means auto-detect\r\n                    backgroundOpacity: 0.85, // set to 0 to avoid background\r\n                    sorted: null    // default to no legend sorting\r\n                },\r\n                xaxis: {\r\n                    show: null, // null = auto-detect, true = always, false = never\r\n                    position: \"bottom\", // or \"top\"\r\n                    mode: null, // null or \"time\"\r\n                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: \"italic\", weight: \"bold\", family: \"sans-serif\", variant: \"small-caps\" }\r\n                    color: null, // base color, labels, ticks\r\n                    tickColor: null, // possibly different color of ticks, e.g. \"rgba(0,0,0,0.15)\"\r\n                    transform: null, // null or f: number -> number to transform axis\r\n                    inverseTransform: null, // if transform is set, this should be the inverse function\r\n                    min: null, // min. value to show, null means set automatically\r\n                    max: null, // max. value to show, null means set automatically\r\n                    autoscaleMargin: null, // margin in % to add if auto-setting min/max\r\n                    ticks: null, // either [1, 3] or [[1, \"a\"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks\r\n                    tickFormatter: null, // fn: number -> string\r\n                    labelWidth: null, // size of tick labels in pixels\r\n                    labelHeight: null,\r\n                    reserveSpace: null, // whether to reserve space even if axis isn't shown\r\n                    tickLength: null, // size in pixels of ticks, or \"full\" for whole line\r\n                    alignTicksWithAxis: null, // axis number or null for no sync\r\n                    tickDecimals: null, // no. of decimals, null means auto\r\n                    tickSize: null, // number or [number, \"unit\"]\r\n                    minTickSize: null // number or [number, \"unit\"]\r\n                },\r\n                yaxis: {\r\n                    autoscaleMargin: 0.02,\r\n                    position: \"left\" // or \"right\"\r\n                },\r\n                xaxes: [],\r\n                yaxes: [],\r\n                series: {\r\n                    points: {\r\n                        show: false,\r\n                        radius: 3,\r\n                        lineWidth: 2, // in pixels\r\n                        fill: true,\r\n                        fillColor: \"#ffffff\",\r\n                        symbol: \"circle\" // or callback\r\n                    },\r\n                    lines: {\r\n                        // we don't put in show: false so we can see\r\n                        // whether lines were actively disabled\r\n                        lineWidth: 2, // in pixels\r\n                        fill: false,\r\n                        fillColor: null,\r\n                        steps: false\r\n                        // Omit 'zero', so we can later default its value to\r\n                        // match that of the 'fill' option.\r\n                    },\r\n                    bars: {\r\n                        show: false,\r\n                        lineWidth: 2, // in pixels\r\n                        barWidth: 1, // in units of the x axis\r\n                        fill: true,\r\n                        fillColor: null,\r\n                        align: \"left\", // \"left\", \"right\", or \"center\"\r\n                        horizontal: false,\r\n                        zero: true\r\n                    },\r\n                    shadowSize: 3,\r\n                    highlightColor: null\r\n                },\r\n                grid: {\r\n                    show: true,\r\n                    aboveData: false,\r\n                    color: \"#545454\", // primary color used for outline and labels\r\n                    backgroundColor: null, // null for transparent, else color\r\n                    borderColor: null, // set if different from the grid color\r\n                    tickColor: null, // color for the ticks, e.g. \"rgba(0,0,0,0.15)\"\r\n                    margin: 0, // distance from the canvas edge to the grid\r\n                    labelMargin: 5, // in pixels\r\n                    eventSectionHeight: 0, // space for event section\r\n                    axisMargin: 8, // in pixels\r\n                    borderWidth: 2, // in pixels\r\n                    minBorderMargin: null, // in pixels, null means taken from points radius\r\n                    markings: null, // array of ranges or fn: axes -> array of ranges\r\n                    markingsColor: \"#f4f4f4\",\r\n                    markingsLineWidth: 2,\r\n                    // interactive stuff\r\n                    clickable: false,\r\n                    hoverable: false,\r\n                    autoHighlight: true, // highlight in case mouse is near\r\n                    mouseActiveRadius: 10 // how far the mouse can be away to activate an item\r\n                },\r\n                interaction: {\r\n                    redrawOverlayInterval: 1000/60 // time between updates, -1 means in same flow\r\n                },\r\n                hooks: {}\r\n            },\r\n        surface = null,     // the canvas for the plot itself\r\n        overlay = null,     // canvas for interactive stuff on top of plot\r\n        eventHolder = null, // jQuery object that events should be bound to\r\n        ctx = null, octx = null,\r\n        xaxes = [], yaxes = [],\r\n        plotOffset = { left: 0, right: 0, top: 0, bottom: 0},\r\n        plotWidth = 0, plotHeight = 0,\r\n        hooks = {\r\n            processOptions: [],\r\n            processRawData: [],\r\n            processDatapoints: [],\r\n            processOffset: [],\r\n            processRange: [],\r\n            drawBackground: [],\r\n            drawSeries: [],\r\n            draw: [],\r\n            bindEvents: [],\r\n            drawOverlay: [],\r\n            shutdown: []\r\n        },\r\n        plot = this;\r\n\r\n        // public functions\r\n        plot.setData = setData;\r\n        plot.setupGrid = setupGrid;\r\n        plot.draw = draw;\r\n        plot.getPlaceholder = function() { return placeholder; };\r\n        plot.getCanvas = function() { return surface.element; };\r\n        plot.getPlotOffset = function() { return plotOffset; };\r\n        plot.width = function () { return plotWidth; };\r\n        plot.height = function () { return plotHeight; };\r\n        plot.offset = function () {\r\n            var o = eventHolder.offset();\r\n            o.left += plotOffset.left;\r\n            o.top += plotOffset.top;\r\n            return o;\r\n        };\r\n        plot.getData = function () { return series; };\r\n        plot.getAxes = function () {\r\n            var res = {}, i;\r\n            $.each(xaxes.concat(yaxes), function (_, axis) {\r\n                if (axis)\r\n                    res[axis.direction + (axis.n != 1 ? axis.n : \"\") + \"axis\"] = axis;\r\n            });\r\n            return res;\r\n        };\r\n        plot.getXAxes = function () { return xaxes; };\r\n        plot.getYAxes = function () { return yaxes; };\r\n        plot.c2p = canvasToAxisCoords;\r\n        plot.p2c = axisToCanvasCoords;\r\n        plot.getOptions = function () { return options; };\r\n        plot.highlight = highlight;\r\n        plot.unhighlight = unhighlight;\r\n        plot.triggerRedrawOverlay = triggerRedrawOverlay;\r\n        plot.pointOffset = function(point) {\r\n            return {\r\n                left: parseInt(xaxes[axisNumber(point, \"x\") - 1].p2c(+point.x) + plotOffset.left, 10),\r\n                top: parseInt(yaxes[axisNumber(point, \"y\") - 1].p2c(+point.y) + plotOffset.top, 10)\r\n            };\r\n        };\r\n        plot.shutdown = shutdown;\r\n        plot.destroy = function () {\r\n            shutdown();\r\n            placeholder.removeData(\"plot\").empty();\r\n\r\n            series = [];\r\n            options = null;\r\n            surface = null;\r\n            overlay = null;\r\n            eventHolder = null;\r\n            ctx = null;\r\n            octx = null;\r\n            xaxes = [];\r\n            yaxes = [];\r\n            hooks = null;\r\n            highlights = [];\r\n            plot = null;\r\n        };\r\n        plot.resize = function () {\r\n        \tvar width = placeholder.width(),\r\n        \t\theight = placeholder.height();\r\n            surface.resize(width, height);\r\n            overlay.resize(width, height);\r\n        };\r\n\r\n        // public attributes\r\n        plot.hooks = hooks;\r\n\r\n        // initialize\r\n        initPlugins(plot);\r\n        parseOptions(options_);\r\n        setupCanvases();\r\n        setData(data_);\r\n        setupGrid();\r\n        draw();\r\n        bindEvents();\r\n\r\n\r\n        function executeHooks(hook, args) {\r\n            args = [plot].concat(args);\r\n            for (var i = 0; i < hook.length; ++i)\r\n                hook[i].apply(this, args);\r\n        }\r\n\r\n        function initPlugins() {\r\n\r\n            // References to key classes, allowing plugins to modify them\r\n\r\n            var classes = {\r\n                Canvas: Canvas\r\n            };\r\n\r\n            for (var i = 0; i < plugins.length; ++i) {\r\n                var p = plugins[i];\r\n                p.init(plot, classes);\r\n                if (p.options)\r\n                    $.extend(true, options, p.options);\r\n            }\r\n        }\r\n\r\n        function parseOptions(opts) {\r\n\r\n            $.extend(true, options, opts);\r\n\r\n            // $.extend merges arrays, rather than replacing them.  When less\r\n            // colors are provided than the size of the default palette, we\r\n            // end up with those colors plus the remaining defaults, which is\r\n            // not expected behavior; avoid it by replacing them here.\r\n\r\n            if (opts && opts.colors) {\r\n            \toptions.colors = opts.colors;\r\n            }\r\n\r\n            if (options.xaxis.color == null)\r\n                options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\r\n            if (options.yaxis.color == null)\r\n                options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\r\n\r\n            if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility\r\n                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;\r\n            if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility\r\n                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;\r\n\r\n            if (options.grid.borderColor == null)\r\n                options.grid.borderColor = options.grid.color;\r\n            if (options.grid.tickColor == null)\r\n                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();\r\n\r\n            // Fill in defaults for axis options, including any unspecified\r\n            // font-spec fields, if a font-spec was provided.\r\n\r\n            // If no x/y axis options were provided, create one of each anyway,\r\n            // since the rest of the code assumes that they exist.\r\n\r\n            var i, axisOptions, axisCount,\r\n                fontSize = placeholder.css(\"font-size\"),\r\n                fontSizeDefault = fontSize ? +fontSize.replace(\"px\", \"\") : 13,\r\n                fontDefaults = {\r\n                    style: placeholder.css(\"font-style\"),\r\n                    size: Math.round(0.8 * fontSizeDefault),\r\n                    variant: placeholder.css(\"font-variant\"),\r\n                    weight: placeholder.css(\"font-weight\"),\r\n                    family: placeholder.css(\"font-family\")\r\n                };\r\n\r\n            axisCount = options.xaxes.length || 1;\r\n            for (i = 0; i < axisCount; ++i) {\r\n\r\n                axisOptions = options.xaxes[i];\r\n                if (axisOptions && !axisOptions.tickColor) {\r\n                    axisOptions.tickColor = axisOptions.color;\r\n                }\r\n\r\n                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);\r\n                options.xaxes[i] = axisOptions;\r\n\r\n                if (axisOptions.font) {\r\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\r\n                    if (!axisOptions.font.color) {\r\n                        axisOptions.font.color = axisOptions.color;\r\n                    }\r\n                    if (!axisOptions.font.lineHeight) {\r\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\r\n                    }\r\n                }\r\n            }\r\n\r\n            axisCount = options.yaxes.length || 1;\r\n            for (i = 0; i < axisCount; ++i) {\r\n\r\n                axisOptions = options.yaxes[i];\r\n                if (axisOptions && !axisOptions.tickColor) {\r\n                    axisOptions.tickColor = axisOptions.color;\r\n                }\r\n\r\n                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);\r\n                options.yaxes[i] = axisOptions;\r\n\r\n                if (axisOptions.font) {\r\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\r\n                    if (!axisOptions.font.color) {\r\n                        axisOptions.font.color = axisOptions.color;\r\n                    }\r\n                    if (!axisOptions.font.lineHeight) {\r\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // backwards compatibility, to be removed in future\r\n            if (options.xaxis.noTicks && options.xaxis.ticks == null)\r\n                options.xaxis.ticks = options.xaxis.noTicks;\r\n            if (options.yaxis.noTicks && options.yaxis.ticks == null)\r\n                options.yaxis.ticks = options.yaxis.noTicks;\r\n            if (options.x2axis) {\r\n                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);\r\n                options.xaxes[1].position = \"top\";\r\n                // Override the inherit to allow the axis to auto-scale\r\n                if (options.x2axis.min == null) {\r\n                    options.xaxes[1].min = null;\r\n                }\r\n                if (options.x2axis.max == null) {\r\n                    options.xaxes[1].max = null;\r\n                }\r\n            }\r\n            if (options.y2axis) {\r\n                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);\r\n                options.yaxes[1].position = \"right\";\r\n                // Override the inherit to allow the axis to auto-scale\r\n                if (options.y2axis.min == null) {\r\n                    options.yaxes[1].min = null;\r\n                }\r\n                if (options.y2axis.max == null) {\r\n                    options.yaxes[1].max = null;\r\n                }\r\n            }\r\n            if (options.grid.coloredAreas)\r\n                options.grid.markings = options.grid.coloredAreas;\r\n            if (options.grid.coloredAreasColor)\r\n                options.grid.markingsColor = options.grid.coloredAreasColor;\r\n            if (options.lines)\r\n                $.extend(true, options.series.lines, options.lines);\r\n            if (options.points)\r\n                $.extend(true, options.series.points, options.points);\r\n            if (options.bars)\r\n                $.extend(true, options.series.bars, options.bars);\r\n            if (options.shadowSize != null)\r\n                options.series.shadowSize = options.shadowSize;\r\n            if (options.highlightColor != null)\r\n                options.series.highlightColor = options.highlightColor;\r\n\r\n            // save options on axes for future reference\r\n            for (i = 0; i < options.xaxes.length; ++i)\r\n                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\r\n            for (i = 0; i < options.yaxes.length; ++i)\r\n                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\r\n\r\n            // add hooks from options\r\n            for (var n in hooks)\r\n                if (options.hooks[n] && options.hooks[n].length)\r\n                    hooks[n] = hooks[n].concat(options.hooks[n]);\r\n\r\n            executeHooks(hooks.processOptions, [options]);\r\n        }\r\n\r\n        function setData(d) {\r\n            series = parseData(d);\r\n            fillInSeriesOptions();\r\n            processData();\r\n        }\r\n\r\n        function parseData(d) {\r\n            var res = [];\r\n            for (var i = 0; i < d.length; ++i) {\r\n                var s = $.extend(true, {}, options.series);\r\n\r\n                if (d[i].data != null) {\r\n                    s.data = d[i].data; // move the data instead of deep-copy\r\n                    delete d[i].data;\r\n\r\n                    $.extend(true, s, d[i]);\r\n\r\n                    d[i].data = s.data;\r\n                }\r\n                else\r\n                    s.data = d[i];\r\n                res.push(s);\r\n            }\r\n\r\n            return res;\r\n        }\r\n\r\n        function axisNumber(obj, coord) {\r\n            var a = obj[coord + \"axis\"];\r\n            if (typeof a == \"object\") // if we got a real axis, extract number\r\n                a = a.n;\r\n            if (typeof a != \"number\")\r\n                a = 1; // default to first axis\r\n            return a;\r\n        }\r\n\r\n        function allAxes() {\r\n            // return flat array without annoying null entries\r\n            return $.grep(xaxes.concat(yaxes), function (a) { return a; });\r\n        }\r\n\r\n        function canvasToAxisCoords(pos) {\r\n            // return an object with x/y corresponding to all used axes\r\n            var res = {}, i, axis;\r\n            for (i = 0; i < xaxes.length; ++i) {\r\n                axis = xaxes[i];\r\n                if (axis && axis.used)\r\n                    res[\"x\" + axis.n] = axis.c2p(pos.left);\r\n            }\r\n\r\n            for (i = 0; i < yaxes.length; ++i) {\r\n                axis = yaxes[i];\r\n                if (axis && axis.used)\r\n                    res[\"y\" + axis.n] = axis.c2p(pos.top);\r\n            }\r\n\r\n            if (res.x1 !== undefined)\r\n                res.x = res.x1;\r\n            if (res.y1 !== undefined)\r\n                res.y = res.y1;\r\n\r\n            return res;\r\n        }\r\n\r\n        function axisToCanvasCoords(pos) {\r\n            // get canvas coords from the first pair of x/y found in pos\r\n            var res = {}, i, axis, key;\r\n\r\n            for (i = 0; i < xaxes.length; ++i) {\r\n                axis = xaxes[i];\r\n                if (axis && axis.used) {\r\n                    key = \"x\" + axis.n;\r\n                    if (pos[key] == null && axis.n == 1)\r\n                        key = \"x\";\r\n\r\n                    if (pos[key] != null) {\r\n                        res.left = axis.p2c(pos[key]);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (i = 0; i < yaxes.length; ++i) {\r\n                axis = yaxes[i];\r\n                if (axis && axis.used) {\r\n                    key = \"y\" + axis.n;\r\n                    if (pos[key] == null && axis.n == 1)\r\n                        key = \"y\";\r\n\r\n                    if (pos[key] != null) {\r\n                        res.top = axis.p2c(pos[key]);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return res;\r\n        }\r\n\r\n        function getOrCreateAxis(axes, number) {\r\n            if (!axes[number - 1])\r\n                axes[number - 1] = {\r\n                    n: number, // save the number for future reference\r\n                    direction: axes == xaxes ? \"x\" : \"y\",\r\n                    options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)\r\n                };\r\n\r\n            return axes[number - 1];\r\n        }\r\n\r\n        function fillInSeriesOptions() {\r\n\r\n            var neededColors = series.length, maxIndex = -1, i;\r\n\r\n            // Subtract the number of series that already have fixed colors or\r\n            // color indexes from the number that we still need to generate.\r\n\r\n            for (i = 0; i < series.length; ++i) {\r\n                var sc = series[i].color;\r\n                if (sc != null) {\r\n                    neededColors--;\r\n                    if (typeof sc == \"number\" && sc > maxIndex) {\r\n                        maxIndex = sc;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // If any of the series have fixed color indexes, then we need to\r\n            // generate at least as many colors as the highest index.\r\n\r\n            if (neededColors <= maxIndex) {\r\n                neededColors = maxIndex + 1;\r\n            }\r\n\r\n            // Generate all the colors, using first the option colors and then\r\n            // variations on those colors once they're exhausted.\r\n\r\n            var c, colors = [], colorPool = options.colors,\r\n                colorPoolSize = colorPool.length, variation = 0;\r\n\r\n            for (i = 0; i < neededColors; i++) {\r\n\r\n                c = $.color.parse(colorPool[i % colorPoolSize] || \"#666\");\r\n\r\n                // Each time we exhaust the colors in the pool we adjust\r\n                // a scaling factor used to produce more variations on\r\n                // those colors. The factor alternates negative/positive\r\n                // to produce lighter/darker colors.\r\n\r\n                // Reset the variation after every few cycles, or else\r\n                // it will end up producing only white or black colors.\r\n\r\n                if (i % colorPoolSize == 0 && i) {\r\n                    if (variation >= 0) {\r\n                        if (variation < 0.5) {\r\n                            variation = -variation - 0.2;\r\n                        } else variation = 0;\r\n                    } else variation = -variation;\r\n                }\r\n\r\n                colors[i] = c.scale('rgb', 1 + variation);\r\n            }\r\n\r\n            // Finalize the series options, filling in their colors\r\n\r\n            var colori = 0, s;\r\n            for (i = 0; i < series.length; ++i) {\r\n                s = series[i];\r\n\r\n                // assign colors\r\n                if (s.color == null) {\r\n                    s.color = colors[colori].toString();\r\n                    ++colori;\r\n                }\r\n                else if (typeof s.color == \"number\")\r\n                    s.color = colors[s.color].toString();\r\n\r\n                // turn on lines automatically in case nothing is set\r\n                if (s.lines.show == null) {\r\n                    var v, show = true;\r\n                    for (v in s)\r\n                        if (s[v] && s[v].show) {\r\n                            show = false;\r\n                            break;\r\n                        }\r\n                    if (show)\r\n                        s.lines.show = true;\r\n                }\r\n\r\n                // If nothing was provided for lines.zero, default it to match\r\n                // lines.fill, since areas by default should extend to zero.\r\n\r\n                if (s.lines.zero == null) {\r\n                    s.lines.zero = !!s.lines.fill;\r\n                }\r\n\r\n                // setup axes\r\n                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, \"x\"));\r\n                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, \"y\"));\r\n            }\r\n        }\r\n\r\n        function processData() {\r\n            var topSentry = Number.POSITIVE_INFINITY,\r\n                bottomSentry = Number.NEGATIVE_INFINITY,\r\n                fakeInfinity = Number.MAX_VALUE,\r\n                i, j, k, m, length,\r\n                s, points, ps, x, y, axis, val, f, p,\r\n                data, format;\r\n\r\n            function updateAxis(axis, min, max) {\r\n                if (min < axis.datamin && min != -fakeInfinity)\r\n                    axis.datamin = min;\r\n                if (max > axis.datamax && max != fakeInfinity)\r\n                    axis.datamax = max;\r\n            }\r\n\r\n            $.each(allAxes(), function (_, axis) {\r\n                // init axis\r\n                axis.datamin = topSentry;\r\n                axis.datamax = bottomSentry;\r\n                axis.used = false;\r\n            });\r\n\r\n            for (i = 0; i < series.length; ++i) {\r\n                s = series[i];\r\n                s.datapoints = { points: [] };\r\n\r\n                executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);\r\n            }\r\n\r\n            // first pass: clean and copy data\r\n            for (i = 0; i < series.length; ++i) {\r\n                s = series[i];\r\n\r\n                data = s.data;\r\n                format = s.datapoints.format;\r\n\r\n                if (!format) {\r\n                    format = [];\r\n                    // find out how to copy\r\n                    format.push({ x: true, number: true, required: true });\r\n                    format.push({ y: true, number: true, required: true });\r\n\r\n                    if (s.bars.show || (s.lines.show && s.lines.fill)) {\r\n                        var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));\r\n                        format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });\r\n                        if (s.bars.horizontal) {\r\n                            delete format[format.length - 1].y;\r\n                            format[format.length - 1].x = true;\r\n                        }\r\n                    }\r\n\r\n                    s.datapoints.format = format;\r\n                }\r\n\r\n                if (s.datapoints.pointsize != null)\r\n                    continue; // already filled in\r\n\r\n                s.datapoints.pointsize = format.length;\r\n\r\n                ps = s.datapoints.pointsize;\r\n                points = s.datapoints.points;\r\n\r\n                var insertSteps = s.lines.show && s.lines.steps;\r\n                s.xaxis.used = s.yaxis.used = true;\r\n\r\n                for (j = k = 0; j < data.length; ++j, k += ps) {\r\n                    p = data[j];\r\n\r\n                    var nullify = p == null;\r\n                    if (!nullify) {\r\n                        for (m = 0; m < ps; ++m) {\r\n                            val = p[m];\r\n                            f = format[m];\r\n\r\n                            if (f) {\r\n                                if (f.number && val != null) {\r\n                                    val = +val; // convert to number\r\n                                    if (isNaN(val))\r\n                                        val = null;\r\n                                    else if (val == Infinity)\r\n                                        val = fakeInfinity;\r\n                                    else if (val == -Infinity)\r\n                                        val = -fakeInfinity;\r\n                                }\r\n\r\n                                if (val == null) {\r\n                                    if (f.required)\r\n                                        nullify = true;\r\n\r\n                                    if (f.defaultValue != null)\r\n                                        val = f.defaultValue;\r\n                                }\r\n                            }\r\n\r\n                            points[k + m] = val;\r\n                        }\r\n                    }\r\n\r\n                    if (nullify) {\r\n                        for (m = 0; m < ps; ++m) {\r\n                            val = points[k + m];\r\n                            if (val != null) {\r\n                                f = format[m];\r\n                                // extract min/max info\r\n                                if (f.autoscale !== false) {\r\n                                    if (f.x) {\r\n                                        updateAxis(s.xaxis, val, val);\r\n                                    }\r\n                                    if (f.y) {\r\n                                        updateAxis(s.yaxis, val, val);\r\n                                    }\r\n                                }\r\n                            }\r\n                            points[k + m] = null;\r\n                        }\r\n                    }\r\n\r\n                    if (insertSteps && k > 0 && (!nullify || points[k - ps] != null)) {\r\n                        // copy the point to make room for a middle point\r\n                        for (m = 0; m < ps; ++m)\r\n                            points[k + ps + m] = points[k + m];\r\n\r\n                        // middle point has same y\r\n                        points[k + 1] = points[k - ps + 1] || 0;\r\n\r\n                        // if series has null values, let's give the last !null value a nice step\r\n                        if(nullify)\r\n                        \tpoints[k] = p[0];\r\n\r\n                        // we've added a point, better reflect that\r\n                        k += ps;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // give the hooks a chance to run\r\n            for (i = 0; i < series.length; ++i) {\r\n                s = series[i];\r\n                points = s.datapoints.points;\r\n                ps = s.datapoints.pointsize;\r\n\r\n                // grafana\r\n                if (s.transform === 'negative-Y') {\r\n                  for (j = 0; j < points.length; j += ps) {\r\n                    if (points[j] == null)\r\n                        continue;\r\n\r\n                      val = points[j + 1];\r\n                      points[j + 1] = -val;\r\n                  }\r\n                }\r\n\r\n                executeHooks(hooks.processDatapoints, [ s, s.datapoints]);\r\n            }\r\n\r\n            // second pass: find datamax/datamin for auto-scaling\r\n            for (i = 0; i < series.length; ++i) {\r\n                s = series[i];\r\n                points = s.datapoints.points;\r\n                ps = s.datapoints.pointsize;\r\n                format = s.datapoints.format;\r\n\r\n                var xmin = topSentry, ymin = topSentry,\r\n                    xmax = bottomSentry, ymax = bottomSentry;\r\n\r\n                for (j = 0; j < points.length; j += ps) {\r\n                    if (points[j] == null)\r\n                        continue;\r\n\r\n                    for (m = 0; m < ps; ++m) {\r\n                        val = points[j + m];\r\n                        f = format[m];\r\n                        if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity)\r\n                            continue;\r\n\r\n                        if (f.x) {\r\n                            if (val < xmin)\r\n                                xmin = val;\r\n                            if (val > xmax)\r\n                                xmax = val;\r\n                        }\r\n                        if (f.y) {\r\n                            if (val < ymin)\r\n                                ymin = val;\r\n                            if (val > ymax)\r\n                                ymax = val;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (s.bars.show) {\r\n                    // make sure we got room for the bar on the dancing floor\r\n                    var delta;\r\n\r\n                    switch (s.bars.align) {\r\n                        case \"left\":\r\n                            delta = 0;\r\n                            break;\r\n                        case \"right\":\r\n                            delta = -s.bars.barWidth;\r\n                            break;\r\n                        default:\r\n                            delta = -s.bars.barWidth / 2;\r\n                    }\r\n\r\n                    if (s.bars.horizontal) {\r\n                        ymin += delta;\r\n                        ymax += delta + s.bars.barWidth;\r\n                    }\r\n                    else {\r\n                        xmin += delta;\r\n                        xmax += delta + s.bars.barWidth;\r\n                    }\r\n                }\r\n\r\n                updateAxis(s.xaxis, xmin, xmax);\r\n                updateAxis(s.yaxis, ymin, ymax);\r\n            }\r\n\r\n            $.each(allAxes(), function (_, axis) {\r\n                if (axis.datamin == topSentry)\r\n                    axis.datamin = null;\r\n                if (axis.datamax == bottomSentry)\r\n                    axis.datamax = null;\r\n            });\r\n        }\r\n\r\n        function setupCanvases() {\r\n            // Make sure the placeholder is clear of everything except canvases\r\n            // from a previous plot in this container that we'll try to re-use.\r\n\r\n            placeholder.find(\".flot-temp-elem\").remove();\r\n\r\n            if (placeholder.css(\"position\") == 'static')\r\n                placeholder.css(\"position\", \"relative\"); // for positioning labels and overlay\r\n\r\n            surface = new Canvas(\"flot-base\", placeholder);\r\n            overlay = new Canvas(\"flot-overlay\", placeholder); // overlay canvas for interactive features\r\n\r\n            ctx = surface.context;\r\n            octx = overlay.context;\r\n\r\n            // define which element we're listening for events on\r\n            eventHolder = $(overlay.element).unbind();\r\n\r\n            // If we're re-using a plot object, shut down the old one\r\n\r\n            var existing = placeholder.data(\"plot\");\r\n\r\n            if (existing) {\r\n                existing.shutdown();\r\n                overlay.clear();\r\n            }\r\n\r\n            // save in case we get replotted\r\n            placeholder.data(\"plot\", plot);\r\n        }\r\n\r\n        function bindEvents() {\r\n            // bind events\r\n            if (options.grid.hoverable) {\r\n                eventHolder.mousemove(onMouseMove);\r\n\r\n                // Use bind, rather than .mouseleave, because we officially\r\n                // still support jQuery 1.2.6, which doesn't define a shortcut\r\n                // for mouseenter or mouseleave.  This was a bug/oversight that\r\n                // was fixed somewhere around 1.3.x.  We can return to using\r\n                // .mouseleave when we drop support for 1.2.6.\r\n\r\n                eventHolder.bind(\"mouseleave\", onMouseLeave);\r\n            }\r\n\r\n            if (options.grid.clickable)\r\n                eventHolder.click(onClick);\r\n\r\n            executeHooks(hooks.bindEvents, [eventHolder]);\r\n        }\r\n\r\n        function shutdown() {\r\n            if (redrawTimeout)\r\n                clearTimeout(redrawTimeout);\r\n\r\n            eventHolder.unbind(\"mousemove\", onMouseMove);\r\n            eventHolder.unbind(\"mouseleave\", onMouseLeave);\r\n            eventHolder.unbind(\"click\", onClick);\r\n\r\n            executeHooks(hooks.shutdown, [eventHolder]);\r\n        }\r\n\r\n        function setTransformationHelpers(axis) {\r\n            // set helper functions on the axis, assumes plot area\r\n            // has been computed already\r\n\r\n            function identity(x) { return x; }\r\n\r\n            var s, m, t = axis.options.transform || identity,\r\n                it = axis.options.inverseTransform;\r\n\r\n            // precompute how much the axis is scaling a point\r\n            // in canvas space\r\n            if (axis.direction == \"x\") {\r\n                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\r\n                m = Math.min(t(axis.max), t(axis.min));\r\n            }\r\n            else {\r\n                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\r\n                s = -s;\r\n                m = Math.max(t(axis.max), t(axis.min));\r\n            }\r\n\r\n            // data point to canvas coordinate\r\n            if (t == identity) // slight optimization\r\n                axis.p2c = function (p) { return (p - m) * s; };\r\n            else\r\n                axis.p2c = function (p) { return (t(p) - m) * s; };\r\n            // canvas coordinate to data point\r\n            if (!it)\r\n                axis.c2p = function (c) { return m + c / s; };\r\n            else\r\n                axis.c2p = function (c) { return it(m + c / s); };\r\n        }\r\n\r\n        function measureTickLabels(axis) {\r\n\r\n            var opts = axis.options,\r\n                ticks = axis.ticks || [],\r\n                labelWidth = opts.labelWidth || 0,\r\n                labelHeight = opts.labelHeight || 0,\r\n                maxWidth = labelWidth || (axis.direction == \"x\" ? Math.floor(surface.width / (ticks.length || 1)) : null),\r\n                legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\r\n                layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\r\n                font = opts.font || \"flot-tick-label tickLabel\";\r\n\r\n            for (var i = 0; i < ticks.length; ++i) {\r\n\r\n                var t = ticks[i];\r\n\r\n                if (!t.label)\r\n                    continue;\r\n\r\n                var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);\r\n\r\n                /// Grafana fix, add +1 to label width\r\n                labelWidth = Math.max(labelWidth, info.width + 1);\r\n                labelHeight = Math.max(labelHeight, info.height);\r\n            }\r\n\r\n            axis.labelWidth = opts.labelWidth || labelWidth;\r\n            axis.labelHeight = opts.labelHeight || labelHeight;\r\n        }\r\n\r\n        function allocateAxisBoxFirstPhase(axis) {\r\n            // find the bounding box of the axis by looking at label\r\n            // widths/heights and ticks, make room by diminishing the\r\n            // plotOffset; this first phase only looks at one\r\n            // dimension per axis, the other dimension depends on the\r\n            // other axes so will have to wait\r\n\r\n            var lw = axis.labelWidth,\r\n                lh = axis.labelHeight,\r\n                pos = axis.options.position,\r\n                isXAxis = axis.direction === \"x\",\r\n                tickLength = axis.options.tickLength,\r\n                axisMargin = options.grid.axisMargin,\r\n                padding = options.grid.labelMargin,\r\n                eventSectionPadding = options.grid.eventSectionHeight,\r\n                innermost = true,\r\n                outermost = true,\r\n                first = true,\r\n                found = false;\r\n\r\n            // Determine the axis's position in its direction and on its side\r\n\r\n            $.each(isXAxis ? xaxes : yaxes, function(i, a) {\r\n                if (a && (a.show || a.reserveSpace)) {\r\n                    if (a === axis) {\r\n                        found = true;\r\n                    } else if (a.options.position === pos) {\r\n                        if (found) {\r\n                            outermost = false;\r\n                        } else {\r\n                            innermost = false;\r\n                        }\r\n                    }\r\n                    if (!found) {\r\n                        first = false;\r\n                    }\r\n                }\r\n            });\r\n\r\n            // The outermost axis on each side has no margin\r\n\r\n            if (outermost) {\r\n                axisMargin = 0;\r\n            }\r\n\r\n            // The ticks for the first axis in each direction stretch across\r\n\r\n            if (tickLength == null) {\r\n                tickLength = first ? \"full\" : 5;\r\n            }\r\n\r\n            if (!isNaN(+tickLength))\r\n                padding += +tickLength;\r\n\r\n            if (isXAxis) {\r\n                // Add space for event section\r\n                lh += padding;\r\n                lh += eventSectionPadding;\r\n\r\n                if (pos == \"bottom\") {\r\n                    plotOffset.bottom += lh + axisMargin;\r\n                    axis.box = { top: surface.height - plotOffset.bottom, height: lh };\r\n                }\r\n                else {\r\n                    axis.box = { top: plotOffset.top + axisMargin, height: lh };\r\n                    plotOffset.top += lh + axisMargin;\r\n                }\r\n            }\r\n            else {\r\n                lw += padding;\r\n\r\n                if (pos == \"left\") {\r\n                    axis.box = { left: plotOffset.left + axisMargin, width: lw };\r\n                    plotOffset.left += lw + axisMargin;\r\n                }\r\n                else {\r\n                    plotOffset.right += lw + axisMargin;\r\n                    axis.box = { left: surface.width - plotOffset.right, width: lw };\r\n                }\r\n            }\r\n\r\n             // save for future reference\r\n            axis.position = pos;\r\n            axis.tickLength = tickLength;\r\n            axis.box.padding = padding;\r\n            axis.box.eventSectionPadding = eventSectionPadding;\r\n            axis.innermost = innermost;\r\n        }\r\n\r\n        function allocateAxisBoxSecondPhase(axis) {\r\n            // now that all axis boxes have been placed in one\r\n            // dimension, we can set the remaining dimension coordinates\r\n            if (axis.direction == \"x\") {\r\n                axis.box.left = plotOffset.left - axis.labelWidth / 2;\r\n                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;\r\n            }\r\n            else {\r\n                axis.box.top = plotOffset.top - axis.labelHeight / 2;\r\n                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;\r\n            }\r\n        }\r\n\r\n        function adjustLayoutForThingsStickingOut() {\r\n            // possibly adjust plot offset to ensure everything stays\r\n            // inside the canvas and isn't clipped off\r\n\r\n            var minMargin = options.grid.minBorderMargin,\r\n                axis, i;\r\n\r\n            // check stuff from the plot (FIXME: this should just read\r\n            // a value from the series, otherwise it's impossible to\r\n            // customize)\r\n            if (minMargin == null) {\r\n                minMargin = 0;\r\n                for (i = 0; i < series.length; ++i)\r\n                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth/2));\r\n            }\r\n\r\n            var margins = {\r\n                left: minMargin,\r\n                right: minMargin,\r\n                top: minMargin,\r\n                bottom: minMargin\r\n            };\r\n\r\n            // check axis labels, note we don't check the actual\r\n            // labels but instead use the overall width/height to not\r\n            // jump as much around with replots\r\n            $.each(allAxes(), function (_, axis) {\r\n                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {\r\n                    if (axis.direction === \"x\") {\r\n                        margins.left = Math.max(margins.left, axis.labelWidth / 2);\r\n                        margins.right = Math.max(margins.right, axis.labelWidth / 2);\r\n                    } else {\r\n                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);\r\n                        margins.top = Math.max(margins.top, axis.labelHeight / 2);\r\n                    }\r\n                }\r\n            });\r\n\r\n            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));\r\n            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));\r\n            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));\r\n            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));\r\n        }\r\n\r\n        function setupGrid() {\r\n            var i, axes = allAxes(), showGrid = options.grid.show;\r\n\r\n            // Initialize the plot's offset from the edge of the canvas\r\n\r\n            for (var a in plotOffset) {\r\n                var margin = options.grid.margin || 0;\r\n                plotOffset[a] = typeof margin == \"number\" ? margin : margin[a] || 0;\r\n            }\r\n\r\n            executeHooks(hooks.processOffset, [plotOffset]);\r\n\r\n            // If the grid is visible, add its border width to the offset\r\n\r\n            for (var a in plotOffset) {\r\n                if(typeof(options.grid.borderWidth) == \"object\") {\r\n                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;\r\n                }\r\n                else {\r\n                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;\r\n                }\r\n            }\r\n\r\n            $.each(axes, function (_, axis) {\r\n                var axisOpts = axis.options;\r\n                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;\r\n                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;\r\n                setRange(axis);\r\n            });\r\n\r\n            executeHooks(hooks.processRange, []);\r\n\r\n            if (showGrid) {\r\n\r\n                var allocatedAxes = $.grep(axes, function (axis) {\r\n                    return axis.show || axis.reserveSpace;\r\n                });\r\n\r\n                var snaped = false;\r\n                for (var i = 0; i < 2; i++) {\r\n                    $.each(allocatedAxes, function (_, axis) {\r\n                        // make the ticks\r\n                        setupTickGeneration(axis);\r\n                        setTicks(axis);\r\n                        snaped = snapRangeToTicks(axis, axis.ticks) || snaped;\r\n                        // find labelWidth/Height for axis\r\n                        measureTickLabels(axis);\r\n                    });\r\n\r\n                    if (snaped && hooks.processRange.length > 0) {\r\n                        executeHooks(hooks.processRange, []);\r\n                        snaped = false;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // with all dimensions calculated, we can compute the\r\n                // axis bounding boxes, start from the outside\r\n                // (reverse order)\r\n                for (i = allocatedAxes.length - 1; i >= 0; --i)\r\n                    allocateAxisBoxFirstPhase(allocatedAxes[i]);\r\n\r\n                // make sure we've got enough space for things that\r\n                // might stick out\r\n                adjustLayoutForThingsStickingOut();\r\n\r\n                $.each(allocatedAxes, function (_, axis) {\r\n                    allocateAxisBoxSecondPhase(axis);\r\n                });\r\n            }\r\n\r\n\r\n            plotWidth = surface.width - plotOffset.left - plotOffset.right;\r\n            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\r\n\r\n            // now we got the proper plot dimensions, we can compute the scaling\r\n            $.each(axes, function (_, axis) {\r\n                setTransformationHelpers(axis);\r\n            });\r\n\r\n            if (showGrid) {\r\n                drawAxisLabels();\r\n            }\r\n\r\n            insertLegend();\r\n        }\r\n\r\n        function setRange(axis) {\r\n            var opts = axis.options,\r\n                min = +(opts.min != null ? opts.min : axis.datamin),\r\n                max = +(opts.max != null ? opts.max : axis.datamax),\r\n                delta = max - min;\r\n\r\n            if (delta == 0.0) {\r\n                // Grafana fix: wide Y min and max using increased wideFactor\r\n                // when all series values are the same\r\n                var wideFactor = 0.25;\r\n                var widen = Math.abs(max == 0 ? 1 : max * wideFactor);\r\n\r\n                if (opts.min == null) {\r\n                  min -= widen;\r\n                }\r\n                // always widen max if we couldn't widen min to ensure we\r\n                // don't fall into min == max which doesn't work\r\n                if (opts.max == null || opts.min != null) {\r\n                  max += widen;\r\n                }\r\n            }\r\n            else {\r\n                // consider autoscaling\r\n                var margin = opts.autoscaleMargin;\r\n                if (margin != null) {\r\n                    if (opts.min == null) {\r\n                        min -= delta * margin;\r\n                        // make sure we don't go below zero if all values\r\n                        // are positive\r\n                        if (min < 0 && axis.datamin != null && axis.datamin >= 0)\r\n                            min = 0;\r\n                    }\r\n                    if (opts.max == null) {\r\n                        max += delta * margin;\r\n                        if (max > 0 && axis.datamax != null && axis.datamax <= 0)\r\n                            max = 0;\r\n                    }\r\n                }\r\n            }\r\n            axis.min = min;\r\n            axis.max = max;\r\n        }\r\n\r\n        function setupTickGeneration(axis) {\r\n            var opts = axis.options;\r\n\r\n            // estimate number of ticks\r\n            var noTicks;\r\n            if (typeof opts.ticks == \"number\" && opts.ticks > 0)\r\n                noTicks = opts.ticks;\r\n            else\r\n                // heuristic based on the model a*sqrt(x) fitted to\r\n                // some data points that seemed reasonable\r\n                noTicks = 0.3 * Math.sqrt(axis.direction == \"x\" ? surface.width : surface.height);\r\n\r\n            var delta = (axis.max - axis.min) / noTicks,\r\n                dec = -Math.floor(Math.log(delta) / Math.LN10),\r\n                maxDec = opts.tickDecimals;\r\n\r\n            if (maxDec != null && dec > maxDec) {\r\n                dec = maxDec;\r\n            }\r\n\r\n            var magn = Math.pow(10, -dec),\r\n                norm = delta / magn, // norm is between 1.0 and 10.0\r\n                size;\r\n\r\n            if (norm < 1.5) {\r\n                size = 1;\r\n            } else if (norm < 3) {\r\n                size = 2;\r\n                // special case for 2.5, requires an extra decimal\r\n                if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {\r\n                    size = 2.5;\r\n                    ++dec;\r\n                }\r\n            } else if (norm < 7.5) {\r\n                size = 5;\r\n            } else {\r\n                size = 10;\r\n            }\r\n\r\n            size *= magn;\r\n\r\n            if (opts.minTickSize != null && size < opts.minTickSize) {\r\n                size = opts.minTickSize;\r\n            }\r\n\r\n            axis.delta = delta;\r\n            axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);\r\n            axis.tickSize = opts.tickSize || size;\r\n            // grafana addition\r\n            axis.scaledDecimals = axis.tickDecimals - Math.floor(Math.log(axis.tickSize) / Math.LN10);\r\n\r\n            // Time mode was moved to a plug-in in 0.8, and since so many people use it\r\n            // we'll add an especially friendly reminder to make sure they included it.\r\n\r\n            if (opts.mode == \"time\" && !axis.tickGenerator) {\r\n                throw new Error(\"Time mode requires the flot.time plugin.\");\r\n            }\r\n\r\n            // Flot supports base-10 axes; any other mode else is handled by a plug-in,\r\n            // like flot.time.js.\r\n\r\n            if (!axis.tickGenerator) {\r\n\r\n                axis.tickGenerator = function (axis) {\r\n\r\n                    var ticks = [],\r\n                        start = floorInBase(axis.min, axis.tickSize),\r\n                        i = 0,\r\n                        v = Number.NaN,\r\n                        prev;\r\n\r\n                    do {\r\n                        prev = v;\r\n                        v = start + i * axis.tickSize;\r\n                        ticks.push(v);\r\n                        ++i;\r\n                    } while (v < axis.max && v != prev);\r\n                    return ticks;\r\n                };\r\n\r\n\t\t\t\taxis.tickFormatter = function (value, axis) {\r\n\r\n\t\t\t\t\tvar factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;\r\n\t\t\t\t\tvar formatted = \"\" + Math.round(value * factor) / factor;\r\n\r\n\t\t\t\t\t// If tickDecimals was specified, ensure that we have exactly that\r\n\t\t\t\t\t// much precision; otherwise default to the value's own precision.\r\n\r\n\t\t\t\t\tif (axis.tickDecimals != null) {\r\n\t\t\t\t\t\tvar decimal = formatted.indexOf(\".\");\r\n\t\t\t\t\t\tvar precision = decimal == -1 ? 0 : formatted.length - decimal - 1;\r\n\t\t\t\t\t\tif (precision < axis.tickDecimals) {\r\n\t\t\t\t\t\t\treturn (precision ? formatted : formatted + \".\") + (\"\" + factor).substr(1, axis.tickDecimals - precision);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n                    return formatted;\r\n                };\r\n            }\r\n\r\n            if ($.isFunction(opts.tickFormatter))\r\n                axis.tickFormatter = function (v, axis) { return \"\" + opts.tickFormatter(v, axis); };\r\n\r\n            if (opts.alignTicksWithAxis != null) {\r\n                var otherAxis = (axis.direction == \"x\" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];\r\n                if (otherAxis && otherAxis.used && otherAxis != axis) {\r\n                    // consider snapping min/max to outermost nice ticks\r\n                    var niceTicks = axis.tickGenerator(axis);\r\n                    if (niceTicks.length > 0) {\r\n                        if (opts.min == null)\r\n                            axis.min = Math.min(axis.min, niceTicks[0]);\r\n                        if (opts.max == null && niceTicks.length > 1)\r\n                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);\r\n                    }\r\n\r\n                    axis.tickGenerator = function (axis) {\r\n                        // copy ticks, scaled to this axis\r\n                        var ticks = [], v, i;\r\n                        for (i = 0; i < otherAxis.ticks.length; ++i) {\r\n                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\r\n                            v = axis.min + v * (axis.max - axis.min);\r\n                            ticks.push(v);\r\n                        }\r\n                        return ticks;\r\n                    };\r\n\r\n                    // we might need an extra decimal since forced\r\n                    // ticks don't necessarily fit naturally\r\n                    if (!axis.mode && opts.tickDecimals == null) {\r\n                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),\r\n                            ts = axis.tickGenerator(axis);\r\n\r\n                        // only proceed if the tick interval rounded\r\n                        // with an extra decimal doesn't give us a\r\n                        // zero at end\r\n                        if (!(ts.length > 1 && /\\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))\r\n                            axis.tickDecimals = extraDec;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function setTicks(axis) {\r\n            var oticks = axis.options.ticks, ticks = [];\r\n            if (oticks == null || (typeof oticks == \"number\" && oticks > 0))\r\n                ticks = axis.tickGenerator(axis);\r\n            else if (oticks) {\r\n                if ($.isFunction(oticks))\r\n                    // generate the ticks\r\n                    ticks = oticks(axis);\r\n                else\r\n                    ticks = oticks;\r\n            }\r\n\r\n            // clean up/labelify the supplied ticks, copy them over\r\n            var i, v;\r\n            axis.ticks = [];\r\n            for (i = 0; i < ticks.length; ++i) {\r\n                var label = null;\r\n                var t = ticks[i];\r\n                if (typeof t == \"object\") {\r\n                    v = +t[0];\r\n                    if (t.length > 1)\r\n                        label = t[1];\r\n                }\r\n                else\r\n                    v = +t;\r\n                if (label == null)\r\n                    label = axis.tickFormatter(v, axis);\r\n                if (!isNaN(v))\r\n                    axis.ticks.push({ v: v, label: label });\r\n            }\r\n        }\r\n\r\n        function snapRangeToTicks(axis, ticks) {\r\n            var changed = false;\r\n            if (axis.options.autoscaleMargin && ticks.length > 0) {\r\n                // snap to ticks\r\n                if (axis.options.min == null) {\r\n                    axis.min = Math.min(axis.min, ticks[0].v);\r\n                    changed = true;\r\n                }\r\n                if (axis.options.max == null && ticks.length > 1) {\r\n                    axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);\r\n                    changed = true;\r\n                }\r\n            }\r\n            return changed;\r\n        }\r\n\r\n        function draw() {\r\n\r\n            surface.clear();\r\n\r\n            executeHooks(hooks.drawBackground, [ctx]);\r\n\r\n            var grid = options.grid;\r\n\r\n            // draw background, if any\r\n            if (grid.show && grid.backgroundColor)\r\n                drawBackground();\r\n\r\n            if (grid.show && !grid.aboveData) {\r\n                drawGrid();\r\n            }\r\n\r\n            for (var i = 0; i < series.length; ++i) {\r\n                executeHooks(hooks.drawSeries, [ctx, series[i]]);\r\n                drawSeries(series[i]);\r\n            }\r\n\r\n            executeHooks(hooks.draw, [ctx]);\r\n\r\n            if (grid.show && grid.aboveData) {\r\n                drawGrid();\r\n            }\r\n\r\n            surface.render();\r\n\r\n            // A draw implies that either the axes or data have changed, so we\r\n            // should probably update the overlay highlights as well.\r\n\r\n            triggerRedrawOverlay();\r\n        }\r\n\r\n        function extractRange(ranges, coord) {\r\n            var axis, from, to, key, axes = allAxes();\r\n\r\n            for (var i = 0; i < axes.length; ++i) {\r\n                axis = axes[i];\r\n                if (axis.direction == coord) {\r\n                    key = coord + axis.n + \"axis\";\r\n                    if (!ranges[key] && axis.n == 1)\r\n                        key = coord + \"axis\"; // support x1axis as xaxis\r\n                    if (ranges[key]) {\r\n                        from = ranges[key].from;\r\n                        to = ranges[key].to;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // backwards-compat stuff - to be removed in future\r\n            if (!ranges[key]) {\r\n                axis = coord == \"x\" ? xaxes[0] : yaxes[0];\r\n                from = ranges[coord + \"1\"];\r\n                to = ranges[coord + \"2\"];\r\n            }\r\n\r\n            // auto-reverse as an added bonus\r\n            if (from != null && to != null && from > to) {\r\n                var tmp = from;\r\n                from = to;\r\n                to = tmp;\r\n            }\r\n\r\n            return { from: from, to: to, axis: axis };\r\n        }\r\n\r\n        function drawBackground() {\r\n            ctx.save();\r\n            ctx.translate(plotOffset.left, plotOffset.top);\r\n\r\n            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, \"rgba(255, 255, 255, 0)\");\r\n            ctx.fillRect(0, 0, plotWidth, plotHeight);\r\n            ctx.restore();\r\n        }\r\n\r\n        function drawGrid() {\r\n            var i, axes, bw, bc;\r\n\r\n            ctx.save();\r\n            ctx.translate(plotOffset.left, plotOffset.top);\r\n\r\n            // draw markings\r\n            var markings = options.grid.markings;\r\n            if (markings) {\r\n                if ($.isFunction(markings)) {\r\n                    axes = plot.getAxes();\r\n                    // xmin etc. is backwards compatibility, to be\r\n                    // removed in the future\r\n                    axes.xmin = axes.xaxis.min;\r\n                    axes.xmax = axes.xaxis.max;\r\n                    axes.ymin = axes.yaxis.min;\r\n                    axes.ymax = axes.yaxis.max;\r\n\r\n                    markings = markings(axes);\r\n                }\r\n\r\n                for (i = 0; i < markings.length; ++i) {\r\n                    var m = markings[i],\r\n                        xrange = extractRange(m, \"x\"),\r\n                        yrange = extractRange(m, \"y\");\r\n\r\n                    // fill in missing\r\n                    if (xrange.from == null)\r\n                        xrange.from = xrange.axis.min;\r\n                    if (xrange.to == null)\r\n                        xrange.to = xrange.axis.max;\r\n                    if (yrange.from == null)\r\n                        yrange.from = yrange.axis.min;\r\n                    if (yrange.to == null)\r\n                        yrange.to = yrange.axis.max;\r\n\r\n                    // clip\r\n                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||\r\n                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)\r\n                        continue;\r\n\r\n                    xrange.from = Math.max(xrange.from, xrange.axis.min);\r\n                    xrange.to = Math.min(xrange.to, xrange.axis.max);\r\n                    yrange.from = Math.max(yrange.from, yrange.axis.min);\r\n                    yrange.to = Math.min(yrange.to, yrange.axis.max);\r\n\r\n                    var xequal = xrange.from === xrange.to,\r\n                        yequal = yrange.from === yrange.to;\r\n\r\n                    if (xequal && yequal) {\r\n                        continue;\r\n                    }\r\n\r\n                    // then draw\r\n                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));\r\n                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));\r\n                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));\r\n                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));\r\n\r\n                    if (xequal || yequal) {\r\n                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,\r\n                            subPixel = lineWidth % 2 ? 0.5 : 0;\r\n                        ctx.beginPath();\r\n                        ctx.strokeStyle = m.color || options.grid.markingsColor;\r\n                        ctx.lineWidth = lineWidth;\r\n                        if (xequal) {\r\n                            ctx.moveTo(xrange.to + subPixel, yrange.from);\r\n                            ctx.lineTo(xrange.to + subPixel, yrange.to);\r\n                        } else {\r\n                            ctx.moveTo(xrange.from, yrange.to + subPixel);\r\n                            ctx.lineTo(xrange.to, yrange.to + subPixel);\r\n                        }\r\n                        ctx.stroke();\r\n                    } else {\r\n                        ctx.fillStyle = m.color || options.grid.markingsColor;\r\n                        ctx.fillRect(xrange.from, yrange.to,\r\n                                     xrange.to - xrange.from,\r\n                                     yrange.from - yrange.to);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // draw the ticks\r\n            axes = allAxes();\r\n            bw = options.grid.borderWidth;\r\n\r\n            for (var j = 0; j < axes.length; ++j) {\r\n                var axis = axes[j], box = axis.box,\r\n                    t = axis.tickLength, x, y, xoff, yoff;\r\n                if (!axis.show || axis.ticks.length == 0)\r\n                    continue;\r\n\r\n                ctx.lineWidth = 1;\r\n\r\n                // find the edges\r\n                if (axis.direction == \"x\") {\r\n                    x = 0;\r\n                    if (t == \"full\")\r\n                        y = (axis.position == \"top\" ? 0 : plotHeight);\r\n                    else\r\n                        y = box.top - plotOffset.top + (axis.position == \"top\" ? box.height : 0);\r\n                }\r\n                else {\r\n                    y = 0;\r\n                    if (t == \"full\")\r\n                        x = (axis.position == \"left\" ? 0 : plotWidth);\r\n                    else\r\n                        x = box.left - plotOffset.left + (axis.position == \"left\" ? box.width : 0);\r\n                }\r\n\r\n                // draw tick bar\r\n                if (!axis.innermost) {\r\n                    ctx.strokeStyle = axis.options.color;\r\n                    ctx.beginPath();\r\n                    xoff = yoff = 0;\r\n                    if (axis.direction == \"x\")\r\n                        xoff = plotWidth + 1;\r\n                    else\r\n                        yoff = plotHeight + 1;\r\n\r\n                    if (ctx.lineWidth == 1) {\r\n                        if (axis.direction == \"x\") {\r\n                            y = Math.floor(y) + 0.5;\r\n                        } else {\r\n                            x = Math.floor(x) + 0.5;\r\n                        }\r\n                    }\r\n\r\n                    ctx.moveTo(x, y);\r\n                    ctx.lineTo(x + xoff, y + yoff);\r\n                    ctx.stroke();\r\n                }\r\n\r\n                // draw ticks\r\n\r\n                ctx.strokeStyle = axis.options.tickColor;\r\n\r\n                ctx.beginPath();\r\n                for (i = 0; i < axis.ticks.length; ++i) {\r\n                    var v = axis.ticks[i].v;\r\n\r\n                    xoff = yoff = 0;\r\n\r\n                    if (isNaN(v) || v < axis.min || v > axis.max\r\n                        // skip those lying on the axes if we got a border\r\n                        || (t == \"full\"\r\n                            && ((typeof bw == \"object\" && bw[axis.position] > 0) || bw > 0)\r\n                            && (v == axis.min || v == axis.max)))\r\n                        continue;\r\n\r\n                    if (axis.direction == \"x\") {\r\n                        x = axis.p2c(v);\r\n                        yoff = t == \"full\" ? -plotHeight : t;\r\n\r\n                        if (axis.position == \"top\")\r\n                            yoff = -yoff;\r\n                    }\r\n                    else {\r\n                        y = axis.p2c(v);\r\n                        xoff = t == \"full\" ? -plotWidth : t;\r\n\r\n                        if (axis.position == \"left\")\r\n                            xoff = -xoff;\r\n                    }\r\n\r\n                    if (ctx.lineWidth == 1) {\r\n                        if (axis.direction == \"x\")\r\n                            x = Math.floor(x) + 0.5;\r\n                        else\r\n                            y = Math.floor(y) + 0.5;\r\n                    }\r\n\r\n                    ctx.moveTo(x, y);\r\n                    ctx.lineTo(x + xoff, y + yoff);\r\n                }\r\n\r\n                ctx.stroke();\r\n            }\r\n\r\n\r\n            // draw border\r\n            if (bw) {\r\n                // If either borderWidth or borderColor is an object, then draw the border\r\n                // line by line instead of as one rectangle\r\n                bc = options.grid.borderColor;\r\n                if(typeof bw == \"object\" || typeof bc == \"object\") {\r\n                    if (typeof bw !== \"object\") {\r\n                        bw = {top: bw, right: bw, bottom: bw, left: bw};\r\n                    }\r\n                    if (typeof bc !== \"object\") {\r\n                        bc = {top: bc, right: bc, bottom: bc, left: bc};\r\n                    }\r\n\r\n                    if (bw.top > 0) {\r\n                        ctx.strokeStyle = bc.top;\r\n                        ctx.lineWidth = bw.top;\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(0 - bw.left, 0 - bw.top/2);\r\n                        ctx.lineTo(plotWidth, 0 - bw.top/2);\r\n                        ctx.stroke();\r\n                    }\r\n\r\n                    if (bw.right > 0) {\r\n                        ctx.strokeStyle = bc.right;\r\n                        ctx.lineWidth = bw.right;\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);\r\n                        ctx.lineTo(plotWidth + bw.right / 2, plotHeight);\r\n                        ctx.stroke();\r\n                    }\r\n\r\n                    if (bw.bottom > 0) {\r\n                        ctx.strokeStyle = bc.bottom;\r\n                        ctx.lineWidth = bw.bottom;\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);\r\n                        ctx.lineTo(0, plotHeight + bw.bottom / 2);\r\n                        ctx.stroke();\r\n                    }\r\n\r\n                    if (bw.left > 0) {\r\n                        ctx.strokeStyle = bc.left;\r\n                        ctx.lineWidth = bw.left;\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(0 - bw.left/2, plotHeight + bw.bottom);\r\n                        ctx.lineTo(0- bw.left/2, 0);\r\n                        ctx.stroke();\r\n                    }\r\n                }\r\n                else {\r\n                    ctx.lineWidth = bw;\r\n                    ctx.strokeStyle = options.grid.borderColor;\r\n                    ctx.strokeRect(-bw/2, -bw/2, plotWidth + bw, plotHeight + bw);\r\n                }\r\n            }\r\n\r\n            ctx.restore();\r\n        }\r\n\r\n        function drawAxisLabels() {\r\n\r\n            $.each(allAxes(), function (_, axis) {\r\n                var box = axis.box,\r\n                    legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\r\n                    layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\r\n                    font = axis.options.font || \"flot-tick-label tickLabel\",\r\n                    tick, x, y, halign, valign;\r\n\r\n                // Remove text before checking for axis.show and ticks.length;\r\n                // otherwise plugins, like flot-tickrotor, that draw their own\r\n                // tick labels will end up with both theirs and the defaults.\r\n\r\n                surface.removeText(layer);\r\n\r\n                if (!axis.show || axis.ticks.length == 0)\r\n                    return;\r\n\r\n                for (var i = 0; i < axis.ticks.length; ++i) {\r\n\r\n                    tick = axis.ticks[i];\r\n                    if (!tick.label || tick.v < axis.min || tick.v > axis.max)\r\n                        continue;\r\n\r\n                    if (axis.direction == \"x\") {\r\n                        halign = \"center\";\r\n                        x = plotOffset.left + axis.p2c(tick.v);\r\n                        if (axis.position == \"bottom\") {\r\n                            y = box.top + box.padding + box.eventSectionPadding;\r\n                        } else {\r\n                            y = box.top + box.height - box.padding;\r\n                            valign = \"bottom\";\r\n                        }\r\n                    } else {\r\n                        valign = \"middle\";\r\n                        y = plotOffset.top + axis.p2c(tick.v);\r\n                        if (axis.position == \"left\") {\r\n                            x = box.left + box.width - box.padding;\r\n                            halign = \"right\";\r\n                        } else {\r\n                            x = box.left + box.padding;\r\n                        }\r\n                    }\r\n\r\n                    surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);\r\n                }\r\n            });\r\n        }\r\n\r\n        function drawSeries(series) {\r\n            if (series.lines.show)\r\n                drawSeriesLines(series);\r\n            if (series.bars.show)\r\n                drawSeriesBars(series);\r\n            if (series.points.show)\r\n                drawSeriesPoints(series);\r\n        }\r\n\r\n        function drawSeriesLines(series) {\r\n            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {\r\n                var points = datapoints.points,\r\n                    ps = datapoints.pointsize,\r\n                    prevx = null, prevy = null;\r\n\r\n                ctx.beginPath();\r\n                for (var i = ps; i < points.length; i += ps) {\r\n                    var x1 = points[i - ps], y1 = points[i - ps + 1],\r\n                        x2 = points[i], y2 = points[i + 1];\r\n\r\n                    if (x1 == null || x2 == null)\r\n                        continue;\r\n\r\n                    // clip with ymin\r\n                    if (y1 <= y2 && y1 < axisy.min) {\r\n                        if (y2 < axisy.min)\r\n                            continue;   // line segment is outside\r\n                        // compute new intersection point\r\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\r\n                        y1 = axisy.min;\r\n                    }\r\n                    else if (y2 <= y1 && y2 < axisy.min) {\r\n                        if (y1 < axisy.min)\r\n                            continue;\r\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\r\n                        y2 = axisy.min;\r\n                    }\r\n\r\n                    // clip with ymax\r\n                    if (y1 >= y2 && y1 > axisy.max) {\r\n                        if (y2 > axisy.max)\r\n                            continue;\r\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\r\n                        y1 = axisy.max;\r\n                    }\r\n                    else if (y2 >= y1 && y2 > axisy.max) {\r\n                        if (y1 > axisy.max)\r\n                            continue;\r\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\r\n                        y2 = axisy.max;\r\n                    }\r\n\r\n                    // clip with xmin\r\n                    if (x1 <= x2 && x1 < axisx.min) {\r\n                        if (x2 < axisx.min)\r\n                            continue;\r\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\r\n                        x1 = axisx.min;\r\n                    }\r\n                    else if (x2 <= x1 && x2 < axisx.min) {\r\n                        if (x1 < axisx.min)\r\n                            continue;\r\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\r\n                        x2 = axisx.min;\r\n                    }\r\n\r\n                    // clip with xmax\r\n                    if (x1 >= x2 && x1 > axisx.max) {\r\n                        if (x2 > axisx.max)\r\n                            continue;\r\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\r\n                        x1 = axisx.max;\r\n                    }\r\n                    else if (x2 >= x1 && x2 > axisx.max) {\r\n                        if (x1 > axisx.max)\r\n                            continue;\r\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\r\n                        x2 = axisx.max;\r\n                    }\r\n\r\n                    if (x1 != prevx || y1 != prevy)\r\n                        ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\r\n\r\n                    prevx = x2;\r\n                    prevy = y2;\r\n                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);\r\n                }\r\n                ctx.stroke();\r\n            }\r\n\r\n            function plotLineArea(datapoints, axisx, axisy) {\r\n                var points = datapoints.points,\r\n                    ps = datapoints.pointsize,\r\n                    bottom = Math.min(Math.max(0, axisy.min), axisy.max),\r\n                    i = 0, top, areaOpen = false,\r\n                    ypos = 1, segmentStart = 0, segmentEnd = 0;\r\n\r\n                // we process each segment in two turns, first forward\r\n                // direction to sketch out top, then once we hit the\r\n                // end we go backwards to sketch the bottom\r\n                while (true) {\r\n                    if (ps > 0 && i > points.length + ps)\r\n                        break;\r\n\r\n                    i += ps; // ps is negative if going backwards\r\n\r\n                    var x1 = points[i - ps],\r\n                        y1 = points[i - ps + ypos],\r\n                        x2 = points[i], y2 = points[i + ypos];\r\n\r\n                    if (areaOpen) {\r\n                        if (ps > 0 && x1 != null && x2 == null) {\r\n                            // at turning point\r\n                            segmentEnd = i;\r\n                            ps = -ps;\r\n                            ypos = 2;\r\n                            continue;\r\n                        }\r\n\r\n                        if (ps < 0 && i == segmentStart + ps) {\r\n                            // done with the reverse sweep\r\n                            ctx.fill();\r\n                            areaOpen = false;\r\n                            ps = -ps;\r\n                            ypos = 1;\r\n                            i = segmentStart = segmentEnd + ps;\r\n                            continue;\r\n                        }\r\n                    }\r\n\r\n                    if (x1 == null || x2 == null)\r\n                        continue;\r\n\r\n                    // clip x values\r\n\r\n                    // clip with xmin\r\n                    if (x1 <= x2 && x1 < axisx.min) {\r\n                        if (x2 < axisx.min)\r\n                            continue;\r\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\r\n                        x1 = axisx.min;\r\n                    }\r\n                    else if (x2 <= x1 && x2 < axisx.min) {\r\n                        if (x1 < axisx.min)\r\n                            continue;\r\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\r\n                        x2 = axisx.min;\r\n                    }\r\n\r\n                    // clip with xmax\r\n                    if (x1 >= x2 && x1 > axisx.max) {\r\n                        if (x2 > axisx.max)\r\n                            continue;\r\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\r\n                        x1 = axisx.max;\r\n                    }\r\n                    else if (x2 >= x1 && x2 > axisx.max) {\r\n                        if (x1 > axisx.max)\r\n                            continue;\r\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\r\n                        x2 = axisx.max;\r\n                    }\r\n\r\n                    if (!areaOpen) {\r\n                        // open area\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\r\n                        areaOpen = true;\r\n                    }\r\n\r\n                    // now first check the case where both is outside\r\n                    if (y1 >= axisy.max && y2 >= axisy.max) {\r\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\r\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\r\n                        continue;\r\n                    }\r\n                    else if (y1 <= axisy.min && y2 <= axisy.min) {\r\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\r\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\r\n                        continue;\r\n                    }\r\n\r\n                    // else it's a bit more complicated, there might\r\n                    // be a flat maxed out rectangle first, then a\r\n                    // triangular cutout or reverse; to find these\r\n                    // keep track of the current x values\r\n                    var x1old = x1, x2old = x2;\r\n\r\n                    // clip the y values, without shortcutting, we\r\n                    // go through all cases in turn\r\n\r\n                    // clip with ymin\r\n                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\r\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\r\n                        y1 = axisy.min;\r\n                    }\r\n                    else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\r\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\r\n                        y2 = axisy.min;\r\n                    }\r\n\r\n                    // clip with ymax\r\n                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\r\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\r\n                        y1 = axisy.max;\r\n                    }\r\n                    else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\r\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\r\n                        y2 = axisy.max;\r\n                    }\r\n\r\n                    // if the x value was changed we got a rectangle\r\n                    // to fill\r\n                    if (x1 != x1old) {\r\n                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));\r\n                        // it goes to (x1, y1), but we fill that below\r\n                    }\r\n\r\n                    // fill triangular section, this sometimes result\r\n                    // in redundant points if (x1, y1) hasn't changed\r\n                    // from previous line to, but we just ignore that\r\n                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\r\n                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\r\n\r\n                    // fill the other rectangle if it's there\r\n                    if (x2 != x2old) {\r\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\r\n                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));\r\n                    }\r\n                }\r\n            }\r\n\r\n            ctx.save();\r\n            ctx.translate(plotOffset.left, plotOffset.top);\r\n            ctx.lineJoin = \"round\";\r\n\r\n            var lw = series.lines.lineWidth,\r\n                sw = series.shadowSize;\r\n            // FIXME: consider another form of shadow when filling is turned on\r\n            if (lw > 0 && sw > 0) {\r\n                // draw shadow as a thick and thin line with transparency\r\n                ctx.lineWidth = sw;\r\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\r\n                // position shadow at angle from the mid of line\r\n                var angle = Math.PI/18;\r\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2), series.xaxis, series.yaxis);\r\n                ctx.lineWidth = sw/2;\r\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4), series.xaxis, series.yaxis);\r\n            }\r\n\r\n            ctx.lineWidth = lw;\r\n            ctx.strokeStyle = series.color;\r\n            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);\r\n            if (fillStyle) {\r\n                ctx.fillStyle = fillStyle;\r\n                plotLineArea(series.datapoints, series.xaxis, series.yaxis);\r\n            }\r\n\r\n            if (lw > 0)\r\n                plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);\r\n            ctx.restore();\r\n        }\r\n\r\n        function drawSeriesPoints(series) {\r\n            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {\r\n                var points = datapoints.points, ps = datapoints.pointsize;\r\n\r\n                for (var i = 0; i < points.length; i += ps) {\r\n                    var x = points[i], y = points[i + 1];\r\n                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\r\n                        continue;\r\n\r\n                    ctx.beginPath();\r\n                    x = axisx.p2c(x);\r\n                    y = axisy.p2c(y) + offset;\r\n                    if (symbol == \"circle\")\r\n                        ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);\r\n                    else\r\n                        symbol(ctx, x, y, radius, shadow);\r\n                    ctx.closePath();\r\n\r\n                    if (fillStyle) {\r\n                        ctx.fillStyle = fillStyle;\r\n                        ctx.fill();\r\n                    }\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n\r\n            ctx.save();\r\n            ctx.translate(plotOffset.left, plotOffset.top);\r\n\r\n            var lw = series.points.lineWidth,\r\n                sw = series.shadowSize,\r\n                radius = series.points.radius,\r\n                symbol = series.points.symbol;\r\n\r\n            // If the user sets the line width to 0, we change it to a very\r\n            // small value. A line width of 0 seems to force the default of 1.\r\n            // Doing the conditional here allows the shadow setting to still be\r\n            // optional even with a lineWidth of 0.\r\n\r\n            if( lw == 0 )\r\n                lw = 0.0001;\r\n\r\n            if (lw > 0 && sw > 0) {\r\n                // draw shadow in two steps\r\n                var w = sw / 2;\r\n                ctx.lineWidth = w;\r\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\r\n                plotPoints(series.datapoints, radius, null, w + w/2, true,\r\n                           series.xaxis, series.yaxis, symbol);\r\n\r\n                ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\r\n                plotPoints(series.datapoints, radius, null, w/2, true,\r\n                           series.xaxis, series.yaxis, symbol);\r\n            }\r\n\r\n            ctx.lineWidth = lw;\r\n            ctx.strokeStyle = series.color;\r\n            plotPoints(series.datapoints, radius,\r\n                       getFillStyle(series.points, series.color), 0, false,\r\n                       series.xaxis, series.yaxis, symbol);\r\n            ctx.restore();\r\n        }\r\n\r\n        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\r\n            var left, right, bottom, top,\r\n                drawLeft, drawRight, drawTop, drawBottom,\r\n                tmp;\r\n\r\n            // in horizontal mode, we start the bar from the left\r\n            // instead of from the bottom so it appears to be\r\n            // horizontal rather than vertical\r\n            if (horizontal) {\r\n                drawBottom = drawRight = drawTop = true;\r\n                drawLeft = false;\r\n                left = b;\r\n                right = x;\r\n                top = y + barLeft;\r\n                bottom = y + barRight;\r\n\r\n                // account for negative bars\r\n                if (right < left) {\r\n                    tmp = right;\r\n                    right = left;\r\n                    left = tmp;\r\n                    drawLeft = true;\r\n                    drawRight = false;\r\n                }\r\n            }\r\n            else {\r\n                drawLeft = drawRight = drawTop = true;\r\n                drawBottom = false;\r\n                left = x + barLeft;\r\n                right = x + barRight;\r\n                bottom = b;\r\n                top = y;\r\n\r\n                // account for negative bars\r\n                if (top < bottom) {\r\n                    tmp = top;\r\n                    top = bottom;\r\n                    bottom = tmp;\r\n                    drawBottom = true;\r\n                    drawTop = false;\r\n                }\r\n            }\r\n\r\n            // clip\r\n            if (right < axisx.min || left > axisx.max ||\r\n                top < axisy.min || bottom > axisy.max)\r\n                return;\r\n\r\n            if (left < axisx.min) {\r\n                left = axisx.min;\r\n                drawLeft = false;\r\n            }\r\n\r\n            if (right > axisx.max) {\r\n                right = axisx.max;\r\n                drawRight = false;\r\n            }\r\n\r\n            if (bottom < axisy.min) {\r\n                bottom = axisy.min;\r\n                drawBottom = false;\r\n            }\r\n\r\n            if (top > axisy.max) {\r\n                top = axisy.max;\r\n                drawTop = false;\r\n            }\r\n\r\n            left = axisx.p2c(left);\r\n            bottom = axisy.p2c(bottom);\r\n            right = axisx.p2c(right);\r\n            top = axisy.p2c(top);\r\n\r\n            // fill the bar\r\n            if (fillStyleCallback) {\r\n                c.fillStyle = fillStyleCallback(bottom, top);\r\n                c.fillRect(left, top, right - left, bottom - top)\r\n            }\r\n\r\n            // draw outline\r\n            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\r\n                c.beginPath();\r\n\r\n                // FIXME: inline moveTo is buggy with excanvas\r\n                c.moveTo(left, bottom);\r\n                if (drawLeft)\r\n                    c.lineTo(left, top);\r\n                else\r\n                    c.moveTo(left, top);\r\n                if (drawTop)\r\n                    c.lineTo(right, top);\r\n                else\r\n                    c.moveTo(right, top);\r\n                if (drawRight)\r\n                    c.lineTo(right, bottom);\r\n                else\r\n                    c.moveTo(right, bottom);\r\n                if (drawBottom)\r\n                    c.lineTo(left, bottom);\r\n                else\r\n                    c.moveTo(left, bottom);\r\n                c.stroke();\r\n            }\r\n        }\r\n\r\n        function drawSeriesBars(series) {\r\n            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {\r\n                var points = datapoints.points, ps = datapoints.pointsize;\r\n\r\n                for (var i = 0; i < points.length; i += ps) {\r\n                    if (points[i] == null)\r\n                        continue;\r\n                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);\r\n                }\r\n            }\r\n\r\n            ctx.save();\r\n            ctx.translate(plotOffset.left, plotOffset.top);\r\n\r\n            // FIXME: figure out a way to add shadows (for instance along the right edge)\r\n            ctx.lineWidth = series.bars.lineWidth;\r\n            ctx.strokeStyle = series.color;\r\n\r\n            var barLeft;\r\n\r\n            switch (series.bars.align) {\r\n                case \"left\":\r\n                    barLeft = 0;\r\n                    break;\r\n                case \"right\":\r\n                    barLeft = -series.bars.barWidth;\r\n                    break;\r\n                default:\r\n                    barLeft = -series.bars.barWidth / 2;\r\n            }\r\n\r\n            var fillStyleCallback = series.bars.fill ? function (bottom, top) { return getFillStyle(series.bars, series.color, bottom, top); } : null;\r\n            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);\r\n            ctx.restore();\r\n        }\r\n\r\n        function getFillStyle(filloptions, seriesColor, bottom, top) {\r\n            var fill = filloptions.fill;\r\n            if (!fill)\r\n                return null;\r\n\r\n            if (filloptions.fillColor)\r\n                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\r\n\r\n            var c = $.color.parse(seriesColor);\r\n            c.a = typeof fill == \"number\" ? fill : 0.4;\r\n            c.normalize();\r\n            return c.toString();\r\n        }\r\n\r\n        function insertLegend() {\r\n\r\n            if (options.legend.container != null) {\r\n                $(options.legend.container).html(\"\");\r\n            } else {\r\n                placeholder.find(\".legend\").remove();\r\n            }\r\n\r\n            if (!options.legend.show) {\r\n                return;\r\n            }\r\n\r\n            var fragments = [], entries = [], rowStarted = false,\r\n                lf = options.legend.labelFormatter, s, label;\r\n\r\n            // Build a list of legend entries, with each having a label and a color\r\n\r\n            for (var i = 0; i < series.length; ++i) {\r\n                s = series[i];\r\n                if (s.label) {\r\n                    label = lf ? lf(s.label, s) : s.label;\r\n                    if (label) {\r\n                        entries.push({\r\n                            label: label,\r\n                            color: s.color\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Sort the legend using either the default or a custom comparator\r\n\r\n            if (options.legend.sorted) {\r\n                if ($.isFunction(options.legend.sorted)) {\r\n                    entries.sort(options.legend.sorted);\r\n                } else if (options.legend.sorted == \"reverse\") {\r\n                \tentries.reverse();\r\n                } else {\r\n                    var ascending = options.legend.sorted != \"descending\";\r\n                    entries.sort(function(a, b) {\r\n                        return a.label == b.label ? 0 : (\r\n                            (a.label < b.label) != ascending ? 1 : -1   // Logical XOR\r\n                        );\r\n                    });\r\n                }\r\n            }\r\n\r\n            // Generate markup for the list of entries, in their final order\r\n\r\n            for (var i = 0; i < entries.length; ++i) {\r\n\r\n                var entry = entries[i];\r\n\r\n                if (i % options.legend.noColumns == 0) {\r\n                    if (rowStarted)\r\n                        fragments.push('</tr>');\r\n                    fragments.push('<tr>');\r\n                    rowStarted = true;\r\n                }\r\n\r\n                fragments.push(\r\n                    '<td class=\"legendColorBox\"><div style=\"border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px\"><div style=\"width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden\"></div></div></td>' +\r\n                    '<td class=\"legendLabel\">' + entry.label + '</td>'\r\n                );\r\n            }\r\n\r\n            if (rowStarted)\r\n                fragments.push('</tr>');\r\n\r\n            if (fragments.length == 0)\r\n                return;\r\n\r\n            var table = '<table style=\"font-size:smaller;color:' + options.grid.color + '\">' + fragments.join(\"\") + '</table>';\r\n            if (options.legend.container != null)\r\n                $(options.legend.container).html(table);\r\n            else {\r\n                var pos = \"\",\r\n                    p = options.legend.position,\r\n                    m = options.legend.margin;\r\n                if (m[0] == null)\r\n                    m = [m, m];\r\n                if (p.charAt(0) == \"n\")\r\n                    pos += 'top:' + (m[1] + plotOffset.top) + 'px;';\r\n                else if (p.charAt(0) == \"s\")\r\n                    pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';\r\n                if (p.charAt(1) == \"e\")\r\n                    pos += 'right:' + (m[0] + plotOffset.right) + 'px;';\r\n                else if (p.charAt(1) == \"w\")\r\n                    pos += 'left:' + (m[0] + plotOffset.left) + 'px;';\r\n                var legend = $('<div class=\"legend\">' + table.replace('style=\"', 'style=\"position:absolute;' + pos +';') + '</div>').appendTo(placeholder);\r\n                if (options.legend.backgroundOpacity != 0.0) {\r\n                    // put in the transparent background\r\n                    // separately to avoid blended labels and\r\n                    // label boxes\r\n                    var c = options.legend.backgroundColor;\r\n                    if (c == null) {\r\n                        c = options.grid.backgroundColor;\r\n                        if (c && typeof c == \"string\")\r\n                            c = $.color.parse(c);\r\n                        else\r\n                            c = $.color.extract(legend, 'background-color');\r\n                        c.a = 1;\r\n                        c = c.toString();\r\n                    }\r\n                    var div = legend.children();\r\n                    $('<div style=\"position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos +'background-color:' + c + ';\"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        // interactive features\r\n\r\n        var highlights = [],\r\n            redrawTimeout = null;\r\n\r\n        // returns the data item the mouse is over, or null if none is found\r\n        function findNearbyItem(mouseX, mouseY, seriesFilter) {\r\n            var maxDistance = options.grid.mouseActiveRadius,\r\n                smallestDistance = maxDistance * maxDistance + 1,\r\n                item = null, foundPoint = false, i, j, ps;\r\n\r\n            for (i = series.length - 1; i >= 0; --i) {\r\n                if (!seriesFilter(series[i]))\r\n                    continue;\r\n\r\n                var s = series[i],\r\n                    axisx = s.xaxis,\r\n                    axisy = s.yaxis,\r\n                    points = s.datapoints.points,\r\n                    mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster\r\n                    my = axisy.c2p(mouseY),\r\n                    maxx = maxDistance / axisx.scale,\r\n                    maxy = maxDistance / axisy.scale;\r\n\r\n                ps = s.datapoints.pointsize;\r\n                // with inverse transforms, we can't use the maxx/maxy\r\n                // optimization, sadly\r\n                if (axisx.options.inverseTransform)\r\n                    maxx = Number.MAX_VALUE;\r\n                if (axisy.options.inverseTransform)\r\n                    maxy = Number.MAX_VALUE;\r\n\r\n                if (s.lines.show || s.points.show) {\r\n                    for (j = 0; j < points.length; j += ps) {\r\n                        var x = points[j], y = points[j + 1];\r\n                        if (x == null)\r\n                            continue;\r\n\r\n                        // For points and lines, the cursor must be within a\r\n                        // certain distance to the data point\r\n                        if (x - mx > maxx || x - mx < -maxx ||\r\n                            y - my > maxy || y - my < -maxy)\r\n                            continue;\r\n\r\n                        // We have to calculate distances in pixels, not in\r\n                        // data units, because the scales of the axes may be different\r\n                        var dx = Math.abs(axisx.p2c(x) - mouseX),\r\n                            dy = Math.abs(axisy.p2c(y) - mouseY),\r\n                            dist = dx * dx + dy * dy; // we save the sqrt\r\n\r\n                        // use <= to ensure last point takes precedence\r\n                        // (last generally means on top of)\r\n                        if (dist < smallestDistance) {\r\n                            smallestDistance = dist;\r\n                            item = [i, j / ps];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (s.bars.show && !item) { // no other point can be nearby\r\n\r\n                    var barLeft, barRight;\r\n\r\n                    switch (s.bars.align) {\r\n                        case \"left\":\r\n                            barLeft = 0;\r\n                            break;\r\n                        case \"right\":\r\n                            barLeft = -s.bars.barWidth;\r\n                            break;\r\n                        default:\r\n                            barLeft = -s.bars.barWidth / 2;\r\n                    }\r\n\r\n                    barRight = barLeft + s.bars.barWidth;\r\n\r\n                    for (j = 0; j < points.length; j += ps) {\r\n                        var x = points[j], y = points[j + 1], b = points[j + 2];\r\n                        if (x == null)\r\n                            continue;\r\n\r\n                        // for a bar graph, the cursor must be inside the bar\r\n                        if (series[i].bars.horizontal ?\r\n                            (mx <= Math.max(b, x) && mx >= Math.min(b, x) &&\r\n                             my >= y + barLeft && my <= y + barRight) :\r\n                            (mx >= x + barLeft && mx <= x + barRight &&\r\n                             my >= Math.min(b, y) && my <= Math.max(b, y)))\r\n                                item = [i, j / ps];\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (item) {\r\n                i = item[0];\r\n                j = item[1];\r\n                ps = series[i].datapoints.pointsize;\r\n\r\n                return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),\r\n                         dataIndex: j,\r\n                         series: series[i],\r\n                         seriesIndex: i };\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        function onMouseMove(e) {\r\n            if (options.grid.hoverable)\r\n                triggerClickHoverEvent(\"plothover\", e,\r\n                                       function (s) { return s[\"hoverable\"] != false; });\r\n        }\r\n\r\n        function onMouseLeave(e) {\r\n            if (options.grid.hoverable)\r\n                triggerClickHoverEvent(\"plothover\", e,\r\n                                       function (s) { return false; });\r\n        }\r\n\r\n        function onClick(e) {\r\n          if (plot.isSelecting) {\r\n            return;\r\n          }\r\n\r\n          triggerClickHoverEvent(\"plotclick\", e, function (s) { return s[\"clickable\"] != false; });\r\n        }\r\n\r\n        // trigger click or hover event (they send the same parameters\r\n        // so we share their code)\r\n        function triggerClickHoverEvent(eventname, event, seriesFilter) {\r\n            var offset = eventHolder.offset(),\r\n                canvasX = event.pageX - offset.left - plotOffset.left,\r\n                canvasY = event.pageY - offset.top - plotOffset.top,\r\n            pos = canvasToAxisCoords({ left: canvasX, top: canvasY });\r\n\r\n            pos.pageX = event.pageX;\r\n            pos.pageY = event.pageY;\r\n\r\n            // Add ctrlKey and metaKey to event\r\n            pos.ctrlKey = event.ctrlKey;\r\n            pos.metaKey = event.metaKey;\r\n\r\n            var item = findNearbyItem(canvasX, canvasY, seriesFilter);\r\n\r\n            if (item) {\r\n                // fill in mouse pos for any listeners out there\r\n                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);\r\n                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);\r\n            }\r\n\r\n            if (options.grid.autoHighlight) {\r\n                // clear auto-highlights\r\n                for (var i = 0; i < highlights.length; ++i) {\r\n                    var h = highlights[i];\r\n                    if (h.auto == eventname &&\r\n                        !(item && h.series == item.series &&\r\n                          h.point[0] == item.datapoint[0] &&\r\n                          h.point[1] == item.datapoint[1]))\r\n                        unhighlight(h.series, h.point);\r\n                }\r\n\r\n                if (item)\r\n                    highlight(item.series, item.datapoint, eventname);\r\n            }\r\n\r\n            placeholder.trigger(eventname, [ pos, item ]);\r\n        }\r\n\r\n        function triggerRedrawOverlay() {\r\n            var t = options.interaction.redrawOverlayInterval;\r\n            if (t == -1) {      // skip event queue\r\n                drawOverlay();\r\n                return;\r\n            }\r\n\r\n            if (!redrawTimeout)\r\n                redrawTimeout = setTimeout(drawOverlay, t);\r\n        }\r\n\r\n        function drawOverlay() {\r\n            redrawTimeout = null;\r\n\r\n            // draw highlights\r\n            octx.save();\r\n            overlay.clear();\r\n            octx.translate(plotOffset.left, plotOffset.top);\r\n\r\n            var i, hi;\r\n            for (i = 0; i < highlights.length; ++i) {\r\n                hi = highlights[i];\r\n\r\n                if (hi.series.bars.show)\r\n                    drawBarHighlight(hi.series, hi.point);\r\n                else\r\n                    drawPointHighlight(hi.series, hi.point);\r\n            }\r\n            octx.restore();\r\n\r\n            executeHooks(hooks.drawOverlay, [octx]);\r\n        }\r\n\r\n        function highlight(s, point, auto) {\r\n            if (typeof s == \"number\")\r\n                s = series[s];\r\n\r\n            if (typeof point == \"number\") {\r\n                var ps = s.datapoints.pointsize;\r\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\r\n            }\r\n\r\n            var i = indexOfHighlight(s, point);\r\n            if (i == -1) {\r\n                highlights.push({ series: s, point: point, auto: auto });\r\n\r\n                triggerRedrawOverlay();\r\n            }\r\n            else if (!auto)\r\n                highlights[i].auto = false;\r\n        }\r\n\r\n        function unhighlight(s, point) {\r\n            if (s == null && point == null) {\r\n                highlights = [];\r\n                triggerRedrawOverlay();\r\n                return;\r\n            }\r\n\r\n            if (typeof s == \"number\")\r\n                s = series[s];\r\n\r\n            if (typeof point == \"number\") {\r\n                var ps = s.datapoints.pointsize;\r\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\r\n            }\r\n\r\n            var i = indexOfHighlight(s, point);\r\n            if (i != -1) {\r\n                highlights.splice(i, 1);\r\n\r\n                triggerRedrawOverlay();\r\n            }\r\n        }\r\n\r\n        function indexOfHighlight(s, p) {\r\n            for (var i = 0; i < highlights.length; ++i) {\r\n                var h = highlights[i];\r\n                if (h.series == s && h.point[0] == p[0]\r\n                    && h.point[1] == p[1])\r\n                    return i;\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        function drawPointHighlight(series, point) {\r\n            var x = point[0], y = point[1],\r\n                axisx = series.xaxis, axisy = series.yaxis,\r\n                highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();\r\n\r\n            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\r\n                return;\r\n\r\n            var pointRadius = series.points.radius + series.points.lineWidth / 2;\r\n            octx.lineWidth = pointRadius;\r\n            octx.strokeStyle = highlightColor;\r\n            var radius = 1.5 * pointRadius;\r\n            x = axisx.p2c(x);\r\n            y = axisy.p2c(y);\r\n\r\n            octx.beginPath();\r\n            if (series.points.symbol == \"circle\")\r\n                octx.arc(x, y, radius, 0, 2 * Math.PI, false);\r\n            else\r\n                series.points.symbol(octx, x, y, radius, false);\r\n            octx.closePath();\r\n            octx.stroke();\r\n        }\r\n\r\n        function drawBarHighlight(series, point) {\r\n            var highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),\r\n                fillStyle = highlightColor,\r\n                barLeft;\r\n\r\n            switch (series.bars.align) {\r\n                case \"left\":\r\n                    barLeft = 0;\r\n                    break;\r\n                case \"right\":\r\n                    barLeft = -series.bars.barWidth;\r\n                    break;\r\n                default:\r\n                    barLeft = -series.bars.barWidth / 2;\r\n            }\r\n\r\n            octx.lineWidth = series.bars.lineWidth;\r\n            octx.strokeStyle = highlightColor;\r\n\r\n            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,\r\n                    function () { return fillStyle; }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);\r\n        }\r\n\r\n        function getColorOrGradient(spec, bottom, top, defaultColor) {\r\n            if (typeof spec == \"string\")\r\n                return spec;\r\n            else {\r\n                // assume this is a gradient spec; IE currently only\r\n                // supports a simple vertical gradient properly, so that's\r\n                // what we support too\r\n                var gradient = ctx.createLinearGradient(0, top, 0, bottom);\r\n\r\n                for (var i = 0, l = spec.colors.length; i < l; ++i) {\r\n                    var c = spec.colors[i];\r\n                    if (typeof c != \"string\") {\r\n                        var co = $.color.parse(defaultColor);\r\n                        if (c.brightness != null)\r\n                            co = co.scale('rgb', c.brightness);\r\n                        if (c.opacity != null)\r\n                            co.a *= c.opacity;\r\n                        c = co.toString();\r\n                    }\r\n                    gradient.addColorStop(i / (l - 1), c);\r\n                }\r\n\r\n                return gradient;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Add the plot function to the top level of the jQuery object\r\n\r\n    $.plot = function(placeholder, data, options) {\r\n        //var t0 = new Date();\r\n        var plot = new Plot($(placeholder), data, options, $.plot.plugins);\r\n        //(window.console ? console.log : alert)(\"time used (msecs): \" + ((new Date()).getTime() - t0.getTime()));\r\n        return plot;\r\n    };\r\n\r\n    $.plot.version = \"0.8.3\";\r\n\r\n    $.plot.plugins = [];\r\n\r\n    // Also add the plot function as a chainable property\r\n\r\n    $.fn.plot = function(data, options) {\r\n        return this.each(function() {\r\n            $.plot(this, data, options);\r\n        });\r\n    };\r\n\r\n    // round to nearby lower multiple of base\r\n    function floorInBase(n, base) {\r\n        return base * Math.floor(n / base);\r\n    }\r\n\r\n})(jQuery);\r\n","/* Pretty handling of time axes.\r\n\r\nCopyright (c) 2007-2013 IOLA and Ole Laursen.\r\nLicensed under the MIT license.\r\n\r\nSet axis.mode to \"time\" to enable. See the section \"Time series data\" in\r\nAPI.txt for details.\r\n\r\n*/\r\n\r\n(function($) {\r\n\r\n\tvar options = {\r\n\t\txaxis: {\r\n\t\t\ttimezone: null,\t\t// \"browser\" for local to the client or timezone for timezone-js\r\n\t\t\ttimeformat: null,\t// format string to use\r\n\t\t\ttwelveHourClock: false,\t// 12 or 24 time in time mode\r\n\t\t\tmonthNames: null\t// list of names of months\r\n\t\t}\r\n\t};\r\n\r\n\t// round to nearby lower multiple of base\r\n\r\n\tfunction floorInBase(n, base) {\r\n\t\treturn base * Math.floor(n / base);\r\n\t}\r\n\r\n\t// Returns a string with the date d formatted according to fmt.\r\n\t// A subset of the Open Group's strftime format is supported.\r\n\r\n\tfunction formatDate(d, fmt, monthNames, dayNames) {\r\n\r\n\t\tif (typeof d.strftime == \"function\") {\r\n\t\t\treturn d.strftime(fmt);\r\n\t\t}\r\n\r\n\t\tvar leftPad = function(n, pad) {\r\n\t\t\tn = \"\" + n;\r\n\t\t\tpad = \"\" + (pad == null ? \"0\" : pad);\r\n\t\t\treturn n.length == 1 ? pad + n : n;\r\n\t\t};\r\n\r\n\t\tvar r = [];\r\n\t\tvar escape = false;\r\n\t\tvar hours = d.getHours();\r\n\t\tvar isAM = hours < 12;\r\n\r\n\t\tif (monthNames == null) {\r\n\t\t\tmonthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\r\n\t\t}\r\n\r\n\t\tif (dayNames == null) {\r\n\t\t\tdayNames = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\r\n\t\t}\r\n\r\n\t\tvar hours12;\r\n\r\n\t\tif (hours > 12) {\r\n\t\t\thours12 = hours - 12;\r\n\t\t} else if (hours == 0) {\r\n\t\t\thours12 = 12;\r\n\t\t} else {\r\n\t\t\thours12 = hours;\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < fmt.length; ++i) {\r\n\r\n\t\t\tvar c = fmt.charAt(i);\r\n\r\n\t\t\tif (escape) {\r\n\t\t\t\tswitch (c) {\r\n\t\t\t\t\tcase 'a': c = \"\" + dayNames[d.getDay()]; break;\r\n\t\t\t\t\tcase 'b': c = \"\" + monthNames[d.getMonth()]; break;\r\n\t\t\t\t\tcase 'd': c = leftPad(d.getDate(), \"\"); break;\r\n\t\t\t\t\tcase 'e': c = leftPad(d.getDate(), \" \"); break;\r\n\t\t\t\t\tcase 'h':\t// For back-compat with 0.7; remove in 1.0\r\n\t\t\t\t\tcase 'H': c = leftPad(hours); break;\r\n\t\t\t\t\tcase 'I': c = leftPad(hours12); break;\r\n\t\t\t\t\tcase 'l': c = leftPad(hours12, \" \"); break;\r\n\t\t\t\t\tcase 'm': c = leftPad(d.getMonth() + 1, \"\"); break;\r\n\t\t\t\t\tcase 'M': c = leftPad(d.getMinutes()); break;\r\n\t\t\t\t\t// quarters not in Open Group's strftime specification\r\n\t\t\t\t\tcase 'q':\r\n\t\t\t\t\t\tc = \"\" + (Math.floor(d.getMonth() / 3) + 1); break;\r\n\t\t\t\t\tcase 'S': c = leftPad(d.getSeconds()); break;\r\n\t\t\t\t\tcase 'y': c = leftPad(d.getFullYear() % 100); break;\r\n\t\t\t\t\tcase 'Y': c = \"\" + d.getFullYear(); break;\r\n\t\t\t\t\tcase 'p': c = (isAM) ? (\"\" + \"am\") : (\"\" + \"pm\"); break;\r\n\t\t\t\t\tcase 'P': c = (isAM) ? (\"\" + \"AM\") : (\"\" + \"PM\"); break;\r\n\t\t\t\t\tcase 'w': c = \"\" + d.getDay(); break;\r\n\t\t\t\t}\r\n\t\t\t\tr.push(c);\r\n\t\t\t\tescape = false;\r\n\t\t\t} else {\r\n\t\t\t\tif (c == \"%\") {\r\n\t\t\t\t\tescape = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tr.push(c);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn r.join(\"\");\r\n\t}\r\n\r\n\t// To have a consistent view of time-based data independent of which time\r\n\t// zone the client happens to be in we need a date-like object independent\r\n\t// of time zones.  This is done through a wrapper that only calls the UTC\r\n\t// versions of the accessor methods.\r\n\r\n\tfunction makeUtcWrapper(d) {\r\n\r\n\t\tfunction addProxyMethod(sourceObj, sourceMethod, targetObj, targetMethod) {\r\n\t\t\tsourceObj[sourceMethod] = function() {\r\n\t\t\t\treturn targetObj[targetMethod].apply(targetObj, arguments);\r\n\t\t\t};\r\n\t\t};\r\n\r\n\t\tvar utc = {\r\n\t\t\tdate: d\r\n\t\t};\r\n\r\n\t\t// support strftime, if found\r\n\r\n\t\tif (d.strftime != undefined) {\r\n\t\t\taddProxyMethod(utc, \"strftime\", d, \"strftime\");\r\n\t\t}\r\n\r\n\t\taddProxyMethod(utc, \"getTime\", d, \"getTime\");\r\n\t\taddProxyMethod(utc, \"setTime\", d, \"setTime\");\r\n\r\n\t\tvar props = [\"Date\", \"Day\", \"FullYear\", \"Hours\", \"Milliseconds\", \"Minutes\", \"Month\", \"Seconds\"];\r\n\r\n\t\tfor (var p = 0; p < props.length; p++) {\r\n\t\t\taddProxyMethod(utc, \"get\" + props[p], d, \"getUTC\" + props[p]);\r\n\t\t\taddProxyMethod(utc, \"set\" + props[p], d, \"setUTC\" + props[p]);\r\n\t\t}\r\n\r\n\t\treturn utc;\r\n\t};\r\n\r\n\t// select time zone strategy.  This returns a date-like object tied to the\r\n\t// desired timezone\r\n\r\n\tfunction dateGenerator(ts, opts) {\r\n\t\tif (opts.timezone == \"browser\") {\r\n\t\t\treturn new Date(ts);\r\n\t\t} else if (!opts.timezone || opts.timezone == \"utc\") {\r\n\t\t\treturn makeUtcWrapper(new Date(ts));\r\n\t\t} else if (typeof timezoneJS != \"undefined\" && typeof timezoneJS.Date != \"undefined\") {\r\n\t\t\tvar d = new timezoneJS.Date();\r\n\t\t\t// timezone-js is fickle, so be sure to set the time zone before\r\n\t\t\t// setting the time.\r\n\t\t\td.setTimezone(opts.timezone);\r\n\t\t\td.setTime(ts);\r\n\t\t\treturn d;\r\n\t\t} else {\r\n\t\t\treturn makeUtcWrapper(new Date(ts));\r\n\t\t}\r\n\t}\r\n\r\n\t// map of app. size of time units in milliseconds\r\n\r\n\tvar timeUnitSize = {\r\n\t\t\"second\": 1000,\r\n\t\t\"minute\": 60 * 1000,\r\n\t\t\"hour\": 60 * 60 * 1000,\r\n\t\t\"day\": 24 * 60 * 60 * 1000,\r\n\t\t\"month\": 30 * 24 * 60 * 60 * 1000,\r\n\t\t\"quarter\": 3 * 30 * 24 * 60 * 60 * 1000,\r\n\t\t\"year\": 365.2425 * 24 * 60 * 60 * 1000\r\n\t};\r\n\r\n\t// the allowed tick sizes, after 1 year we use\r\n\t// an integer algorithm\r\n\r\n\tvar baseSpec = [\r\n\t\t[1, \"second\"], [2, \"second\"], [5, \"second\"], [10, \"second\"],\r\n\t\t[30, \"second\"],\r\n\t\t[1, \"minute\"], [2, \"minute\"], [5, \"minute\"], [10, \"minute\"],\r\n\t\t[30, \"minute\"],\r\n\t\t[1, \"hour\"], [2, \"hour\"], [4, \"hour\"],\r\n\t\t[8, \"hour\"], [12, \"hour\"],\r\n\t\t[1, \"day\"], [2, \"day\"], [3, \"day\"],\r\n\t\t[0.25, \"month\"], [0.5, \"month\"], [1, \"month\"],\r\n\t\t[2, \"month\"]\r\n\t];\r\n\r\n\t// we don't know which variant(s) we'll need yet, but generating both is\r\n\t// cheap\r\n\r\n\tvar specMonths = baseSpec.concat([[3, \"month\"], [6, \"month\"],\r\n\t\t[1, \"year\"]]);\r\n\tvar specQuarters = baseSpec.concat([[1, \"quarter\"], [2, \"quarter\"],\r\n\t\t[1, \"year\"]]);\r\n\r\n\tfunction init(plot) {\r\n\t\tplot.hooks.processOptions.push(function (plot, options) {\r\n\t\t\t$.each(plot.getAxes(), function(axisName, axis) {\r\n\r\n\t\t\t\tvar opts = axis.options;\r\n\r\n\t\t\t\tif (opts.mode == \"time\") {\r\n\t\t\t\t\taxis.tickGenerator = function(axis) {\r\n\r\n\t\t\t\t\t\tvar ticks = [];\r\n\t\t\t\t\t\tvar d = dateGenerator(axis.min, opts);\r\n\t\t\t\t\t\tvar minSize = 0;\r\n\r\n\t\t\t\t\t\t// make quarter use a possibility if quarters are\r\n\t\t\t\t\t\t// mentioned in either of these options\r\n\r\n\t\t\t\t\t\tvar spec = (opts.tickSize && opts.tickSize[1] ===\r\n\t\t\t\t\t\t\t\"quarter\") ||\r\n\t\t\t\t\t\t\t(opts.minTickSize && opts.minTickSize[1] ===\r\n\t\t\t\t\t\t\t\"quarter\") ? specQuarters : specMonths;\r\n\r\n\t\t\t\t\t\tif (opts.minTickSize != null) {\r\n\t\t\t\t\t\t\tif (typeof opts.tickSize == \"number\") {\r\n\t\t\t\t\t\t\t\tminSize = opts.tickSize;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tminSize = opts.minTickSize[0] * timeUnitSize[opts.minTickSize[1]];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor (var i = 0; i < spec.length - 1; ++i) {\r\n\t\t\t\t\t\t\tif (axis.delta < (spec[i][0] * timeUnitSize[spec[i][1]]\r\n\t\t\t\t\t\t\t\t\t\t\t  + spec[i + 1][0] * timeUnitSize[spec[i + 1][1]]) / 2\r\n\t\t\t\t\t\t\t\t&& spec[i][0] * timeUnitSize[spec[i][1]] >= minSize) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar size = spec[i][0];\r\n\t\t\t\t\t\tvar unit = spec[i][1];\r\n\r\n\t\t\t\t\t\t// special-case the possibility of several years\r\n\r\n\t\t\t\t\t\tif (unit == \"year\") {\r\n\r\n\t\t\t\t\t\t\t// if given a minTickSize in years, just use it,\r\n\t\t\t\t\t\t\t// ensuring that it's an integer\r\n\r\n\t\t\t\t\t\t\tif (opts.minTickSize != null && opts.minTickSize[1] == \"year\") {\r\n\t\t\t\t\t\t\t\tsize = Math.floor(opts.minTickSize[0]);\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tvar magn = Math.pow(10, Math.floor(Math.log(axis.delta / timeUnitSize.year) / Math.LN10));\r\n\t\t\t\t\t\t\t\tvar norm = (axis.delta / timeUnitSize.year) / magn;\r\n\r\n\t\t\t\t\t\t\t\tif (norm < 1.5) {\r\n\t\t\t\t\t\t\t\t\tsize = 1;\r\n\t\t\t\t\t\t\t\t} else if (norm < 3) {\r\n\t\t\t\t\t\t\t\t\tsize = 2;\r\n\t\t\t\t\t\t\t\t} else if (norm < 7.5) {\r\n\t\t\t\t\t\t\t\t\tsize = 5;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tsize = 10;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tsize *= magn;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// minimum size for years is 1\r\n\r\n\t\t\t\t\t\t\tif (size < 1) {\r\n\t\t\t\t\t\t\t\tsize = 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\taxis.tickSize = opts.tickSize || [size, unit];\r\n\t\t\t\t\t\tvar tickSize = axis.tickSize[0];\r\n\t\t\t\t\t\tunit = axis.tickSize[1];\r\n\r\n\t\t\t\t\t\tvar step = tickSize * timeUnitSize[unit];\r\n\r\n\t\t\t\t\t\tif (unit == \"second\") {\r\n\t\t\t\t\t\t\td.setSeconds(floorInBase(d.getSeconds(), tickSize));\r\n\t\t\t\t\t\t} else if (unit == \"minute\") {\r\n\t\t\t\t\t\t\td.setMinutes(floorInBase(d.getMinutes(), tickSize));\r\n\t\t\t\t\t\t} else if (unit == \"hour\") {\r\n\t\t\t\t\t\t\td.setHours(floorInBase(d.getHours(), tickSize));\r\n\t\t\t\t\t\t} else if (unit == \"month\") {\r\n\t\t\t\t\t\t\td.setMonth(floorInBase(d.getMonth(), tickSize));\r\n\t\t\t\t\t\t} else if (unit == \"quarter\") {\r\n\t\t\t\t\t\t\td.setMonth(3 * floorInBase(d.getMonth() / 3,\r\n\t\t\t\t\t\t\t\ttickSize));\r\n\t\t\t\t\t\t} else if (unit == \"year\") {\r\n\t\t\t\t\t\t\td.setFullYear(floorInBase(d.getFullYear(), tickSize));\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// reset smaller components\r\n\r\n\t\t\t\t\t\td.setMilliseconds(0);\r\n\r\n\t\t\t\t\t\tif (step >= timeUnitSize.minute) {\r\n\t\t\t\t\t\t\td.setSeconds(0);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (step >= timeUnitSize.hour) {\r\n\t\t\t\t\t\t\td.setMinutes(0);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (step >= timeUnitSize.day) {\r\n\t\t\t\t\t\t\td.setHours(0);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (step >= timeUnitSize.day * 4) {\r\n\t\t\t\t\t\t\td.setDate(1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (step >= timeUnitSize.month * 2) {\r\n\t\t\t\t\t\t\td.setMonth(floorInBase(d.getMonth(), 3));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (step >= timeUnitSize.quarter * 2) {\r\n\t\t\t\t\t\t\td.setMonth(floorInBase(d.getMonth(), 6));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (step >= timeUnitSize.year) {\r\n\t\t\t\t\t\t\td.setMonth(0);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar carry = 0;\r\n\t\t\t\t\t\tvar v = Number.NaN;\r\n\t\t\t\t\t\tvar prev;\r\n\r\n\t\t\t\t\t\tdo {\r\n\r\n\t\t\t\t\t\t\tprev = v;\r\n\t\t\t\t\t\t\tv = d.getTime();\r\n\t\t\t\t\t\t\tticks.push(v);\r\n\r\n\t\t\t\t\t\t\tif (unit == \"month\" || unit == \"quarter\") {\r\n\t\t\t\t\t\t\t\tif (tickSize < 1) {\r\n\r\n\t\t\t\t\t\t\t\t\t// a bit complicated - we'll divide the\r\n\t\t\t\t\t\t\t\t\t// month/quarter up but we need to take\r\n\t\t\t\t\t\t\t\t\t// care of fractions so we don't end up in\r\n\t\t\t\t\t\t\t\t\t// the middle of a day\r\n\r\n\t\t\t\t\t\t\t\t\td.setDate(1);\r\n\t\t\t\t\t\t\t\t\tvar start = d.getTime();\r\n\t\t\t\t\t\t\t\t\td.setMonth(d.getMonth() +\r\n\t\t\t\t\t\t\t\t\t\t(unit == \"quarter\" ? 3 : 1));\r\n\t\t\t\t\t\t\t\t\tvar end = d.getTime();\r\n\t\t\t\t\t\t\t\t\td.setTime(v + carry * timeUnitSize.hour + (end - start) * tickSize);\r\n\t\t\t\t\t\t\t\t\tcarry = d.getHours();\r\n\t\t\t\t\t\t\t\t\td.setHours(0);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\td.setMonth(d.getMonth() +\r\n\t\t\t\t\t\t\t\t\t\ttickSize * (unit == \"quarter\" ? 3 : 1));\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else if (unit == \"year\") {\r\n\t\t\t\t\t\t\t\td.setFullYear(d.getFullYear() + tickSize);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\td.setTime(v + step);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} while (v < axis.max && v != prev);\r\n\r\n\t\t\t\t\t\treturn ticks;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\taxis.tickFormatter = function (v, axis) {\r\n\r\n\t\t\t\t\t\tvar d = dateGenerator(v, axis.options);\r\n\r\n\t\t\t\t\t\t// first check global format\r\n\r\n\t\t\t\t\t\tif (opts.timeformat != null) {\r\n\t\t\t\t\t\t\treturn formatDate(d, opts.timeformat, opts.monthNames, opts.dayNames);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// possibly use quarters if quarters are mentioned in\r\n\t\t\t\t\t\t// any of these places\r\n\r\n\t\t\t\t\t\tvar useQuarters = (axis.options.tickSize &&\r\n\t\t\t\t\t\t\t\taxis.options.tickSize[1] == \"quarter\") ||\r\n\t\t\t\t\t\t\t(axis.options.minTickSize &&\r\n\t\t\t\t\t\t\t\taxis.options.minTickSize[1] == \"quarter\");\r\n\r\n\t\t\t\t\t\tvar t = axis.tickSize[0] * timeUnitSize[axis.tickSize[1]];\r\n\t\t\t\t\t\tvar span = axis.max - axis.min;\r\n\t\t\t\t\t\tvar suffix = (opts.twelveHourClock) ? \" %p\" : \"\";\r\n\t\t\t\t\t\tvar hourCode = (opts.twelveHourClock) ? \"%I\" : \"%H\";\r\n\t\t\t\t\t\tvar fmt;\r\n\r\n\t\t\t\t\t\tif (t < timeUnitSize.minute) {\r\n\t\t\t\t\t\t\tfmt = hourCode + \":%M:%S\" + suffix;\r\n\t\t\t\t\t\t} else if (t < timeUnitSize.day) {\r\n\t\t\t\t\t\t\tif (span < 2 * timeUnitSize.day) {\r\n\t\t\t\t\t\t\t\tfmt = hourCode + \":%M\" + suffix;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tfmt = \"%b %d \" + hourCode + \":%M\" + suffix;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (t < timeUnitSize.month) {\r\n\t\t\t\t\t\t\tfmt = \"%b %d\";\r\n\t\t\t\t\t\t} else if ((useQuarters && t < timeUnitSize.quarter) ||\r\n\t\t\t\t\t\t\t(!useQuarters && t < timeUnitSize.year)) {\r\n\t\t\t\t\t\t\tif (span < timeUnitSize.year) {\r\n\t\t\t\t\t\t\t\tfmt = \"%b\";\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tfmt = \"%b %Y\";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (useQuarters && t < timeUnitSize.year) {\r\n\t\t\t\t\t\t\tif (span < timeUnitSize.year) {\r\n\t\t\t\t\t\t\t\tfmt = \"Q%q\";\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tfmt = \"Q%q %Y\";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tfmt = \"%Y\";\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar rt = formatDate(d, fmt, opts.monthNames, opts.dayNames);\r\n\r\n\t\t\t\t\t\treturn rt;\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\t$.plot.plugins.push({\r\n\t\tinit: init,\r\n\t\toptions: options,\r\n\t\tname: 'time',\r\n\t\tversion: '1.0'\r\n\t});\r\n\r\n\t// Time-axis support used to be in Flot core, which exposed the\r\n\t// formatDate function on the plot object.  Various plugins depend\r\n\t// on the function, so we need to re-expose it here.\r\n\r\n\t$.plot.formatDate = formatDate;\r\n\r\n})(jQuery);\r\n"],"sourceRoot":""}